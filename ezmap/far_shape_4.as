/* ************************************************************************ *//*																			*//*  FAR + SHP + DBF Sample													*//*  Copyright (c)2007 Edwin van Rijkom										*//*  http://www.vanrijkom.org												*//*																			*//* ************************************************************************ *The 'mexico.far' arhive this sample uses was created from the sample Shapefilematerials from the Shapelib C library (http://shapelib.maptools.org/). Afterdownloading 'shape_eg_data.zip' (from http://dl.maptools.org/dl/shapelib/) thefollowing steps were made to build 'mexico.far' from it:- extract 'mexico' folder from 'shape_eg_data.zip'- run: far.exe mexico.far mexico  builds the mexico.far arhive, including all files from the mexico folder.- run: far.exe -n mexico.far  creates mexico.xml, the manifest describing mexico.far's contents- edited mexico.xml, added a priority for 'states.shp' so it will be first in  the archive. Commented out all source files, excluding:    * states.shp	* roads.shp	* rivers.shp	* cities.shp	* cities.dbf- run: far.exe -m mexico.xml  re-creates the mexico.far archive, this time only including the files listed  in the manifest, placing files in the order dictated by the specified   priorities.  More info on the FAR archiver tool and its options is available at:http://code.google.com/p/vanrijkom-flashlibs/wiki/FarArchiverSetuphttp://code.google.com/p/vanrijkom-flashlibs/wiki/FarArchiverSyntax*/package{import flash.display.DisplayObjectContainer;import flash.display.DisplayObject;import flash.display.Sprite;import flash.display.StageAlign;import flash.display.StageScaleMode;import flash.display.Graphics;import flash.text.TextField;import flash.text.TextFieldAutoSize;import flash.text.TextFormat;import flash.text.TextFieldType;//import flash.events.Event;//import flash.events.SecurityErrorEvent;import flash.events.*; import flash.net.URLRequest;import flash.utils.ByteArray;import flash.geom.Rectangle;import org.vanrijkom.far.*;import org.fenton.shp.*;import org.fenton.tooltips.Rollover;import org.vanrijkom.dbf.*;//import com.dVyper.utils.Alert;[SWF(width="620",height="250", frameRate="24", backgroundColor="0xFFFFFF")]public class far_shape_4 extends Sprite{	private var status	: TextField;		private var far		: FarStream;	private var states	: FarItem;//	private var rivers	: FarItem;//	private var roads	: FarItem;//	private var cities	: FarItem;//	private var citiesdb: FarItem;			// This is the multiplier between map units (degrees) and pixels; 	private var zi: Number = 15;	private var s: Sprite = new Sprite();	private var g: Graphics = s.graphics;		private var highlightsprite: Sprite = new Sprite();		private var ro:Rollover;		var listeners: Array = [];		public function far_shape_4() {		//Alert.init(stage);		//Alert.show("Loading image.", {buttons:["OK"]});		init();	}		private function init():void {			// Instantiate a FarStream		far	= new FarStream();				// Get FarItem instances for the files we expect to		// find in our FAR arhive:		states	= far.item("world4.shp");		//rivers	= far.item("mexico/rivers.shp");		//roads	= far.item("mexico/roads.shp");		//cities	= far.item("mexico/cities.shp");		//citiesdb= far.item("mexico/cities.dbf");				// Listen to 'states.shp' completing: it is the highest 		// priority file in the archive, and will thus be triggered		// first. We can use this to setup the child sprite we'll		// be using for drawing:		states.addEventListener(Event.COMPLETE, drawStates);				// Listen to the full archive complete loading. On receiving		// this event, rivers, roads and all other assets will have		// fully loaded:		//far.addEventListener(Event.COMPLETE, drawOthers);						// Start loading the archive.		far.load(new URLRequest("world4.far"));		ro  = new Rollover(stage);	}		private function handlemousemove(x:int, y:int, msg:int, p):void {		ro.moveto(x,y);		ro.sethtmltext("viewing county: " + msg);		ShpTools.drawPolyOutline(highlightsprite.graphics, p, zi, 0xF7A100, 0);}		private function handlemouseout():void {		//Alert.show("msg: " + msg + "moused over " + x + ", " + y, {background:"blur"});		ro.hide();		highlightsprite.graphics.clear();	}													private function drawStates(e: Event):void {		// Rewritten to add each shape in it's own sprite so we can attach listeners to each sprite		var shp: ShpHeader = new ShpHeader(states.data);		if 	(	shp.shapeType != ShpType.SHAPE_POLYGON 			&& 	shp.shapeType != ShpType.SHAPE_POLYLINE			) 			throw(new ShpError("Shapefile does not contain Polygon records (found type: "+shp.shapeType+")"));							var records: Array = ShpTools.readRecords(states.data);									var shape_count:int = 0;//		for each(var p: ShpRecord in records) {			records.forEach(function(p:ShpRecord,i:int, a:Array):void {					var s2: Sprite = new Sprite();			var g2: Graphics = s2.graphics;			g2.lineStyle(0.01,0xFFFFFF);			ShpTools.drawPolyShp(g2, p, zi, 0xC3D6E1, 1);									// It's critical that the final argument (useweakreference) be false, otherwise the event listener will be tossed as out of scope, or some such.						s2.addEventListener(MouseEvent.MOUSE_MOVE, function(e:MouseEvent):void {					// Get the coordinates in stageX/stageY -- the actual sprite is scaled with a zoom factor					handlemousemove(e.stageX, e.stageY, i, p)				}, false, 0, false);			s2.addEventListener(MouseEvent.MOUSE_OUT, function(e:MouseEvent):void {					// Get the coordinates in stageX/stageY -- the actual sprite is scaled with a zoom factor					handlemouseout()				}, false, 0, false);									shape_count++;			s.addChild(s2);			s.addChild(highlightsprite);					});						// add sprite to canvas:		addChild(s);			// scale the clip to nicely fit our canvas:				scaleToFitCanvas(s,shp,zi);			}		public function drawOthers(e: Event): void {		// draw rivers:	//	g.lineStyle(0.01,0xFF);	//	ShpTools.drawPolyShpFile(rivers.data,g,z);				// draw roads:	//	g.lineStyle(0.01,0xFF0000);	//	ShpTools.drawPolyShpFile(roads.data,g,zi);				// process cities: 		//   - SHP file defines city locations (x,y),		//   - DBF file city names (amongst other things).				// parse the header of the Shapefile loaded in cities.data:	//	var shp: ShpHeader = new ShpHeader(cities.data);		// parse the header of the Shapefile loaded in citiesdb.data:	//	var dbf: DbfHeader = new DbfHeader(citiesdb.data);		// draw city name labels:		/*		drawDbfLabelsAtShpPoints			( s, zi				// target DisplayObjectContainer and zoom level			, cities.data		// ByteArray containing Shapefile			, shp				// Parsed Shapefile header			, citiesdb.data		// ByteArray containing DBF file			, dbf				// Parsed DBF file header			, "NAME"			// Value field name to use a label caption			);	*/	}					public function scaleToFitCanvas(t: DisplayObject, shp: ShpHeader, zoom: Number): void {		// fit to requested width/height:		var r: Rectangle 	= getBounds(t);				var f: Number 		= Math.min								( stage.stageHeight / r.height								, stage.stageWidth / r.width								);				// set calculated scale:		if (f!=Infinity) 			t.scaleX = t.scaleY = f;				// maintain top-left position:		t.x = -shp.boundsXY.left * zoom * f;		t.y = (shp.boundsXY.bottom-shp.boundsXY.top) * zoom * f;				//			}}} // package