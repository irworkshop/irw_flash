// A zoomable, moveable map// Adapted from Edwin van Rijkom's FAR + SHP + DBF Sample	// For more info, see: http://www.vanrijkom.org		package{import flash.display.DisplayObjectContainer;import flash.display.DisplayObject;import flash.display.Sprite;import flash.display.StageAlign;import flash.display.StageScaleMode;import flash.display.Graphics;import flash.text.TextField;import flash.text.TextFieldAutoSize;import flash.text.TextFormat;import flash.text.TextFieldType;//import flash.events.Event;//import flash.events.SecurityErrorEvent;import flash.events.*; import flash.net.URLRequest;import flash.utils.ByteArray;import flash.geom.Rectangle;// flash's crazy import scheme for components, which I think must be dragged into the library.import fl.controls.Label;import fl.controls.Slider;import fl.events.SliderEvent;import fl.controls.SliderDirection;import org.vanrijkom.far.*;import org.fenton.shp.*;import org.fenton.tooltips.Rollover;import org.vanrijkom.dbf.*;import com.dVyper.utils.Alert;[SWF(width="950",height="350", frameRate="24", backgroundColor="0xFFFFFF")]public class zoom_3 extends Sprite{	private var status	: TextField;		var stagewidth:int = 950;	var stageheight:int = 350; 			private var far		: FarStream;	private var world	: FarItem;	private var worlddb	: FarItem;			// This is the multiplier between map units (degrees) and unscaled pixels. 	private var zi: Number = 15;	private var s: Sprite = new Sprite();	private var g: Graphics = s.graphics;		private var highlightsprite: Sprite = new Sprite();		private var ro:Rollover;	private var curzoomlevel:int = 1;	private var basezoomlevel:Number = 1;			public function zoom_3() {		Alert.init(stage);		init();	}		private function init():void {			// Instantiate a FarStream		far	= new FarStream();				// Get FarItem instances for the files we expect to		// find in our FAR arhive:		world	= far.item("world5.shp");		worlddb	= far.item("world5.dbf");		//		// Download both files before we draw--the way we draw depends on the .dbffile		//		worlddb.addEventListener(Event.COMPLETE, drawworld);				far.load(new URLRequest("world5.far"));		ro  = new Rollover(stage);		// Make the map draggable		stage.addEventListener(MouseEvent.MOUSE_DOWN,startmapdrag)		stage.addEventListener(MouseEvent.MOUSE_UP,stopmapdrag)							}		private function handlemousemove(x:int, y:int, msg:int, p, lbldata, dbf):void {		ro.moveto(x,y);				var dr: DbfRecord = DbfTools.getRecord			( lbldata	// ByteArray containing DBF file			, dbf		// Parsed DBF file header			, msg			// index of record to read			);			// DbfRecord.values is a dictionary: field			// values can be retreived like so:		var country_name:String = dr.values['NAME'];		//var state_name:String = dr.values['STATE_NAME'];		//var pop_density:int = dr.values['POP09_SQMI'];		//var lng:Number = dr.values['CENTROID_X'];		//var lat:Number = dr.values['CENTROID_Y'];				ro.sethtmltext("<b>" + country_name + "<br>" );		ShpTools.drawPolyOutline(highlightsprite.graphics, p, zi, 0xF7A100, 0);}		private function handlemouseout():void {		//Alert.show("msg: " + msg + "moused over " + x + ", " + y, {background:"blur"});		ro.hide();		highlightsprite.graphics.clear();	}													private function drawworld(e: Event):void {		// Parse the dbf header		var dbf: DbfHeader = new DbfHeader(worlddb.data);					// Rewritten to add each shape in it's own sprite so we can attach listeners to each sprite		var shp: ShpHeader = new ShpHeader(world.data);		if 	(	shp.shapeType != ShpType.SHAPE_POLYGON 			&& 	shp.shapeType != ShpType.SHAPE_POLYLINE			) 			throw(new ShpError("Shapefile does not contain Polygon records (found type: "+shp.shapeType+")"));							var records: Array = ShpTools.readRecords(world.data);									var shape_count:int = 0;//		for each(var p: ShpRecord in records) {			records.forEach(function(p:ShpRecord,i:int, a:Array):void {					var s2: Sprite = new Sprite();			var g2: Graphics = s2.graphics;			g2.lineStyle(0.01,0xFFFFFF);			ShpTools.drawPolyShp(g2, p, zi, 0xC3D6E1, 1);									// It's critical that the final argument (useweakreference) be false, otherwise the event listener will be tossed as out of scope, or some such.						s2.addEventListener(MouseEvent.MOUSE_MOVE, function(e:MouseEvent):void {					// Get the coordinates in stageX/stageY -- the actual sprite is scaled with a zoom factor					handlemousemove(e.stageX, e.stageY, i, p, worlddb.data, dbf)				}, false, 0, false);			s2.addEventListener(MouseEvent.MOUSE_OUT, function(e:MouseEvent):void {					// Get the coordinates in stageX/stageY -- the actual sprite is scaled with a zoom factor					handlemouseout()				}, false, 0, false);									shape_count++;			s.addChild(s2);			s.addChild(highlightsprite);						// Now draw the zoom box, so it sits on top of everything else. 								});						// add sprite to canvas:		addChild(s);			// scale the clip to nicely fit our canvas:				scaleToFitCanvas(s,shp,zi);				drawzoombox();	}		private function drawzoombox():void {		var slidersprite = new Sprite();								slidersprite.graphics.lineStyle(3,0x666666);		slidersprite.graphics.beginFill(0xFFFFFF, 1);				slidersprite.graphics.drawRect(0,0,50,90);		slidersprite.graphics.endFill();						// We have to explicitly set the width of all the text label fields.		// If we don't, their default size is big enough that it interfere's 		// with the mouse event listeners on the map. 		var zoomtitle:Label = new Label();		//myLabel.autoSize = TextFieldAutoSize.LEFT;		zoomtitle.text = "ZOOM";		zoomtitle.x=5;		zoomtitle.y=5;		zoomtitle.width=40;		slidersprite.addChild(zoomtitle);				var zoomplus:Label = new Label();		//myLabel.autoSize = TextFieldAutoSize.LEFT;		zoomplus.text = "+";		zoomplus.x=33;		zoomplus.y=18;		zoomplus.width = 10;		slidersprite.addChild(zoomplus);						var zoomminus:Label = new Label();		//myLabel.autoSize = TextFieldAutoSize.LEFT;		zoomminus.text = "-";		zoomminus.x=33;		zoomminus.y=68;		zoomminus.width = 10;		slidersprite.addChild(zoomminus);								var zoomslider:Slider = new Slider();		//mySlider.addEventListener(SliderEvent.THUMB_DRAG, thumbDragHandler);				zoomslider.snapInterval = 1; 		zoomslider.tickInterval = 1; 		zoomslider.maximum = 3; 		zoomslider.minimum = 1		zoomslider.value = 1; 		zoomslider.x = 20;		zoomslider.y = 27;		zoomslider.liveDragging = true;						//s.move(myLabel.x, myLabel.y + myLabel.height);				zoomslider.direction = SliderDirection.VERTICAL;		zoomslider.setSize(20, 50);				slidersprite.addChild(zoomslider);		// Ignore mouse clicks 		slidersprite.addEventListener(MouseEvent.MOUSE_DOWN,onStopPropDown,false, 0, true);		//slidersprite.addEventListener(MouseEvent.MOUSE_UP,onStopPropDown,false, 0, true);						slidersprite.x = 10;		slidersprite.y = 10;		addChild(slidersprite);		zoomslider.addEventListener(SliderEvent.CHANGE, zoomChange);	}		public function scaleToFitCanvas(t: DisplayObject, shp: ShpHeader, zoom: Number): void {		// fit to requested width/height:		var r: Rectangle 	= getBounds(t);				var f: Number 		= Math.min								( stage.stageHeight / r.height								, stage.stageWidth / r.width								);				// set calculated scale:		if (f!=Infinity) 			t.scaleX = t.scaleY = f;			// set the class variable so we can zoom further in later			basezoomlevel = f;				// maintain top-left position:		t.x = -shp.boundsXY.left * zoom * f;		t.y = (shp.boundsXY.bottom-shp.boundsXY.top) * zoom * f;				//			}		function startmapdrag(e:Event):void{	trace("start drag");	s.startDrag(); }                        function stopmapdrag(e:Event):void{	s.stopDrag();	trace("stop drag");	}	function zoomChange(e:SliderEvent):void {	var newzoom:int = e.target.value;	// Make the zoom levels be 1, 2, 4 	if (newzoom == 3) {		newzoom = 4;	}		// size of s2 sprite to begin with	var initial_width:int = stagewidth * curzoomlevel;	var initial_height:int = stageheight * curzoomlevel; 		//The current center in sprite coordinates	var curcenterx:Number = stagewidth/2 - s.x;	var curcentery:Number = stageheight/2 -s.y;		// The relative position of the center	var relativecenterx:Number = curcenterx / initial_width;	var relativecentery:Number = curcentery / initial_height;			//Alert.show('zooming to ' + newzoom + " with zi " + zi + " basezoomlevel: " + basezoomlevel, {buttons:["OK"]});		//Now reset the zoom level:			curzoomlevel=newzoom;	// Scale the sprite to fit			s.scaleX = s.scaleY = curzoomlevel * basezoomlevel;		// New dimensions	var final_width:int = stagewidth * curzoomlevel;	var final_height:int = stageheight * curzoomlevel;		// Calculate the center in terms of the zoomed sprite		var finalx:Number = relativecenterx * final_width;	var finaly:Number = relativecentery * final_height;		// Now calculate the new offsets	var finaloffsetx:Number = stagewidth/2 - finalx;	var finaloffsety:Number = stageheight/2 - finaly;		s.x = finaloffsetx;	s.y = finaloffsety;	}	function onStopPropDown(evt:MouseEvent):void {//output.text = "stopProp down";	evt.stopPropagation();}			} // class} // package