/* ************************************************************************ *//*																			*//*  FAR + SHP + DBF Sample													*//*  Copyright (c)2007 Edwin van Rijkom										*//*  http://www.vanrijkom.org												*//*																			*//* ************************************************************************ *The 'mexico.far' arhive this sample uses was created from the sample Shapefilematerials from the Shapelib C library (http://shapelib.maptools.org/). Afterdownloading 'shape_eg_data.zip' (from http://dl.maptools.org/dl/shapelib/) thefollowing steps were made to build 'mexico.far' from it:- extract 'mexico' folder from 'shape_eg_data.zip'- run: far.exe mexico.far mexico  builds the mexico.far arhive, including all files from the mexico folder.- run: far.exe -n mexico.far  creates mexico.xml, the manifest describing mexico.far's contents- edited mexico.xml, added a priority for 'world.shp' so it will be first in  the archive. Commented out all source files, excluding:    * world.shp	* roads.shp	* rivers.shp	* cities.shp	* cities.dbf- run: far.exe -m mexico.xml  re-creates the mexico.far archive, this time only including the files listed  in the manifest, placing files in the order dictated by the specified   priorities.  More info on the FAR archiver tool and its options is available at:http://code.google.com/p/vanrijkom-flashlibs/wiki/FarArchiverSetuphttp://code.google.com/p/vanrijkom-flashlibs/wiki/FarArchiverSyntax*/package{import flash.display.DisplayObjectContainer;import flash.display.DisplayObject;import flash.display.Sprite;import flash.display.StageAlign;import flash.display.StageScaleMode;import flash.display.Graphics;import flash.text.TextField;import flash.text.TextFieldAutoSize;import flash.text.TextFormat;import flash.text.TextFieldType;//import flash.events.Event;//import flash.events.SecurityErrorEvent;import flash.events.*; import flash.net.URLRequest;import flash.utils.ByteArray;import flash.geom.Rectangle;import org.vanrijkom.far.*;import org.fenton.shp.*;import org.fenton.tooltips.Rollover;import org.vanrijkom.dbf.*;//import com.dVyper.utils.Alert;[SWF(width="620",height="250", frameRate="24", backgroundColor="0xFFFFFF")]public class zoom_3 extends Sprite{	private var status	: TextField;		private var far		: FarStream;	private var world	: FarItem;	private var worlddb	: FarItem;			// This is the multiplier between map units (degrees) and unscaled pixels. 	private var zi: Number = 15;	private var s: Sprite = new Sprite();	private var g: Graphics = s.graphics;		private var highlightsprite: Sprite = new Sprite();		private var ro:Rollover;			public function zoom_3() {		//Alert.init(stage);		//Alert.show("Loading image.", {buttons:["OK"]});		init();	}		private function init():void {			// Instantiate a FarStream		far	= new FarStream();				// Get FarItem instances for the files we expect to		// find in our FAR arhive:		world	= far.item("world4.shp");		worlddb	= far.item("world4.dbf");		//		// Download both files before we draw--the way we draw depends on the .dbffile		//		worlddb.addEventListener(Event.COMPLETE, drawworld);				far.load(new URLRequest("world4.far"));		ro  = new Rollover(stage);		// Make the map draggable		stage.addEventListener(MouseEvent.MOUSE_DOWN,startmapdrag)		stage.addEventListener(MouseEvent.MOUSE_UP,stopmapdrag)	}		private function handlemousemove(x:int, y:int, msg:int, p, lbldata, dbf):void {		ro.moveto(x,y);				var dr: DbfRecord = DbfTools.getRecord			( lbldata	// ByteArray containing DBF file			, dbf		// Parsed DBF file header			, msg			// index of record to read			);			// DbfRecord.values is a dictionary: field			// values can be retreived like so:		var country_name:String = dr.values['NAME'];		var num_mech:int = dr.values['TOTAL'];		var cert_mech:int = dr.values['TOT_CERT'];		var lng:Number = dr.values['CENTROID_X'];		var lat:Number = dr.values['CENTROID_Y'];				ro.sethtmltext("<b>" + country_name + "</b><br>" + num_mech + " mechanics" +  "<br>centroid " + lng + ", " + lat);		ShpTools.drawPolyOutline(highlightsprite.graphics, p, zi, 0xF7A100, 0);}		private function handlemouseout():void {		//Alert.show("msg: " + msg + "moused over " + x + ", " + y, {background:"blur"});		ro.hide();		highlightsprite.graphics.clear();	}													private function drawworld(e: Event):void {		// Parse the dbf header		var dbf: DbfHeader = new DbfHeader(worlddb.data);					// Rewritten to add each shape in it's own sprite so we can attach listeners to each sprite		var shp: ShpHeader = new ShpHeader(world.data);		if 	(	shp.shapeType != ShpType.SHAPE_POLYGON 			&& 	shp.shapeType != ShpType.SHAPE_POLYLINE			) 			throw(new ShpError("Shapefile does not contain Polygon records (found type: "+shp.shapeType+")"));							var records: Array = ShpTools.readRecords(world.data);									var shape_count:int = 0;//		for each(var p: ShpRecord in records) {			records.forEach(function(p:ShpRecord,i:int, a:Array):void {					var s2: Sprite = new Sprite();			var g2: Graphics = s2.graphics;			g2.lineStyle(0.01,0xFFFFFF);			ShpTools.drawPolyShp(g2, p, zi, 0xC3D6E1, 1);									// It's critical that the final argument (useweakreference) be false, otherwise the event listener will be tossed as out of scope, or some such.						s2.addEventListener(MouseEvent.MOUSE_MOVE, function(e:MouseEvent):void {					// Get the coordinates in stageX/stageY -- the actual sprite is scaled with a zoom factor					handlemousemove(e.stageX, e.stageY, i, p, worlddb.data, dbf)				}, false, 0, false);			s2.addEventListener(MouseEvent.MOUSE_OUT, function(e:MouseEvent):void {					// Get the coordinates in stageX/stageY -- the actual sprite is scaled with a zoom factor					handlemouseout()				}, false, 0, false);									shape_count++;			s.addChild(s2);			s.addChild(highlightsprite);					});						// add sprite to canvas:		addChild(s);			// scale the clip to nicely fit our canvas:				scaleToFitCanvas(s,shp,zi);			}		public function drawOthers(e: Event): void {		// parse the header of the Shapefile loaded in cities.data:	//	var shp: ShpHeader = new ShpHeader(cities.data);		// parse the header of the Shapefile loaded in citiesdb.data:	//	var dbf: DbfHeader = new DbfHeader(citiesdb.data);		// draw city name labels:		/*		drawDbfLabelsAtShpPoints			( s, zi				// target DisplayObjectContainer and zoom level			, cities.data		// ByteArray containing Shapefile			, shp				// Parsed Shapefile header			, citiesdb.data		// ByteArray containing DBF file			, dbf				// Parsed DBF file header			, "NAME"			// Value field name to use a label caption			);	*/	}					public function scaleToFitCanvas(t: DisplayObject, shp: ShpHeader, zoom: Number): void {		// fit to requested width/height:		var r: Rectangle 	= getBounds(t);				var f: Number 		= Math.min								( stage.stageHeight / r.height								, stage.stageWidth / r.width								);				// set calculated scale:		if (f!=Infinity) 			t.scaleX = t.scaleY = f;				// maintain top-left position:		t.x = -shp.boundsXY.left * zoom * f;		t.y = (shp.boundsXY.bottom-shp.boundsXY.top) * zoom * f;				//			}		function startmapdrag(e:Event):void{	trace("start drag");	s.startDrag(); }                        function stopmapdrag(e:Event):void{	s.stopDrag();	trace("stop drag");	}	} // class} // package