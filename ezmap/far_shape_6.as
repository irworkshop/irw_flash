// ************************************************************************ //																			//  Adapted from Edwin van Rijkom's FAR + SHP + DBF Sample													//  For more info, see: http://www.vanrijkom.org//  Hacked together by jacob fenton//// ************************************************************************ package{import flash.display.DisplayObjectContainer;import flash.display.DisplayObject;import flash.display.Sprite;import flash.display.StageAlign;import flash.display.StageScaleMode;import flash.display.Graphics;import flash.text.TextField;import flash.text.TextFieldAutoSize;import flash.text.TextFormat;import flash.text.TextFieldType;//import flash.events.Event;//import flash.events.SecurityErrorEvent;import flash.events.*; import flash.net.URLRequest;import flash.utils.ByteArray;import flash.geom.Rectangle;import org.vanrijkom.far.*;import org.fenton.shp.*;import org.fenton.tooltips.Rollover;import org.vanrijkom.dbf.*;//import com.dVyper.utils.Alert;[SWF(width="620",height="250", frameRate="24", backgroundColor="0xFFFFFF")]public class far_shape_6 extends Sprite{	private var status	: TextField;		private var far		: FarStream;	private var world	: FarItem;	private var worlddb	: FarItem;			// This is the multiplier between map units (degrees) and unscaled pixels. 	private var zi: Number = 15;	private var s: Sprite = new Sprite();	private var g: Graphics = s.graphics;		private var highlightsprite: Sprite = new Sprite();		private var ro:Rollover;			public function far_shape_6() {				// initialize dVyper's alert class:		//Alert.init(stage);				//Send an alert on start		//var radius:int = getcircleradius(10000)		//Alert.show("radius for 10000 = " + radius, {buttons:["OK"]});		init();	}		private function init():void {			// Instantiate a FarStream		far	= new FarStream();				// Get FarItem instances for the files we expect to		// find in our FAR arhive:		world	= far.item("world4.shp");		worlddb	= far.item("world4.dbf");		//		// Download both files before we draw--the way we draw depends on the .dbffile		//		worlddb.addEventListener(Event.COMPLETE, drawworld);				far.load(new URLRequest("world4.far"));		ro  = new Rollover(stage);	}		private function handlemouseover(x:int, y:int, msg:int, p, lbldata, dbf):void {		ro.moveto(x,y);				var dr: DbfRecord = DbfTools.getRecord			( lbldata	// ByteArray containing DBF file			, dbf		// Parsed DBF file header			, msg			// index of record to read			);			// DbfRecord.values is a dictionary: field			// values can be retreived like so:		var country_name:String = dr.values['NAME'];		var num_mech:int = dr.values['TOTAL'];		var cert_mech:int = dr.values['TOT_CERT'];		var lng:Number = dr.values['CENTROID_X'];		var lat:Number = dr.values['CENTROID_Y'];				ro.sethtmltext("<font face='Arial Bold'>" + country_name + "<br></font><font face='Arial'>" + num_mech + " mechanics" +  "<br>" + cert_mech + " certified</font>");				var radius:int =  getcircleradius(num_mech);		Circle(highlightsprite.graphics,lng, -lat, radius, 0xFF0000, 0.6, 1, 0x000000, 1, zi); 		ShpTools.drawPolyOutline(highlightsprite.graphics, p, zi, 0x4C8BA9, 0);}		private function handlemousemove(x:int, y:int):void {		ro.moveto(x,y);	}	private function handlemouseout():void {		//Alert.show("msg: " + msg + "moused over " + x + ", " + y, {background:"blur"});		ro.hide();		highlightsprite.graphics.clear();	}													private function drawworld(e: Event):void {		// Parse the dbf header		var dbf: DbfHeader = new DbfHeader(worlddb.data);					// Rewritten to add each shape in it's own sprite so we can attach listeners to each sprite		var shp: ShpHeader = new ShpHeader(world.data);		if 	(	shp.shapeType != ShpType.SHAPE_POLYGON 			&& 	shp.shapeType != ShpType.SHAPE_POLYLINE			) 			throw(new ShpError("Shapefile does not contain Polygon records (found type: "+shp.shapeType+")"));							var records: Array = ShpTools.readRecords(world.data);							// Put the circles in this array, then sort them by size before rendering, so the smallest are plotted last.		var circles_holder:Array = new Array();					var shape_count:int = 0;		var scircles: Sprite = new Sprite();		var gcircles: Graphics = scircles.graphics;//		for each(var p: ShpRecord in records) {			records.forEach(function(p:ShpRecord,i:int, a:Array):void {					var s2: Sprite = new Sprite();			var g2: Graphics = s2.graphics;						var scircle: Sprite = new Sprite();			var gcircle: Graphics = scircle.graphics;						g2.lineStyle(0.01,0xFFFFFF);									var dr: DbfRecord = DbfTools.getRecord				( worlddb.data	// ByteArray containing DBF file				, dbf		// Parsed DBF file header				, i			// index of record to read				);			// DbfRecord.values is a dictionary: field			// values can be retreived like so:			var num_mech:int = dr.values['TOTAL'];			var lng:Number = dr.values['CENTROID_X'];			var lat:Number = dr.values['CENTROID_Y'];				//if ( (num_mech > 0) && (i==194) ) {			if ( num_mech > 0 ) {					var radius:int =  getcircleradius(num_mech);				//Circle(gcircle,lng, -lat, radius, 0xFF0000, 0.3, 1, 0x666666, 0.4, zi); 				var circle_temp:Sprite = circle_sprite(lng, -lat, radius, 0xFF0000, 0.3, 1, 0x666666, 0.4, zi); 									//E0C2C6				//C3D6E1				ShpTools.drawPolyShp(g2, p, zi, 0xC3D6E1, 1); 	//public function Circle(g:Graphics, center_x:Number, center_y:Number, radius:int, fillcolor:uint, fillalpha:Number, outlinewidth:int, outlinecolor:uint, outlinealpha: Number, zoom:Number):Sprite {							   			// It's critical that the final argument (useweakreference) be false, otherwise the event listener will be tossed as out of scope, or some such.							circle_temp.addEventListener(MouseEvent.MOUSE_OVER, function(e:MouseEvent):void {						// Get the coordinates in stageX/stageY -- the actual sprite is scaled with a zoom factor						handlemouseover(e.stageX, e.stageY, i, p, worlddb.data, dbf)					}, false, 0, false);				circle_temp.addEventListener(MouseEvent.MOUSE_MOVE, function(e:MouseEvent):void {						// Get the coordinates in stageX/stageY -- the actual sprite is scaled with a zoom factor						handlemousemove(e.stageX, e.stageY)					}, false, 0, false);									circle_temp.addEventListener(MouseEvent.MOUSE_OUT, function(e:MouseEvent):void {						// Get the coordinates in stageX/stageY -- the actual sprite is scaled with a zoom factor						handlemouseout()					}, false, 0, false);								// Don't add it to gcircle yet -- we want to sort it by size and then add it to gcircle;								var circle_holder = new Object();				circle_holder.csprite = circle_temp;				circle_holder.radius = radius;				// Add it the circles_holder Array;				circles_holder.push(circle_holder);									} else {				ShpTools.drawPolyShp(g2, p, zi, 0xEDEDED, 1);							}										shape_count++;			s.addChild(s2);//			scircles.addChild(scircle);					});						// add sprite to canvas:		s.addChild(highlightsprite);						// Add the circles, sorted by radius;		circles_holder = circles_holder.sortOn("radius", Array.DESCENDING | Array.NUMERIC);				 		var i:int;		for (i=0; i< circles_holder.length; i++) {			scircles.addChild(circles_holder[i].csprite);			trace(i + " : " + circles_holder[i].radius);		}				s.addChild(scircles);				addChild(s);	// scale the clip to nicely fit our canvas:				scaleToFitCanvas(s,shp,zi);			}		public function drawOthers(e: Event): void {		// parse the header of the Shapefile loaded in cities.data:	//	var shp: ShpHeader = new ShpHeader(cities.data);		// parse the header of the Shapefile loaded in citiesdb.data:	//	var dbf: DbfHeader = new DbfHeader(citiesdb.data);		// draw city name labels:		/*		drawDbfLabelsAtShpPoints			( s, zi				// target DisplayObjectContainer and zoom level			, cities.data		// ByteArray containing Shapefile			, shp				// Parsed Shapefile header			, citiesdb.data		// ByteArray containing DBF file			, dbf				// Parsed DBF file header			, "NAME"			// Value field name to use a label caption			);	*/	}					public function scaleToFitCanvas(t: DisplayObject, shp: ShpHeader, zoom: Number): void {		// fit to requested width/height:		var r: Rectangle 	= getBounds(t);				var f: Number 		= Math.min								( stage.stageHeight / r.height								, stage.stageWidth / r.width								);				// set calculated scale:		if (f!=Infinity) 			t.scaleX = t.scaleY = f;				// maintain top-left position:		t.x = -shp.boundsXY.left * zoom * f;		t.y = (shp.boundsXY.bottom-shp.boundsXY.top) * zoom * f;				//			}			public function Circle(g:Graphics, center_x:Number, center_y:Number, radius:int, fillcolor:uint, fillalpha:Number, outlinewidth:int, outlinecolor:uint, outlinealpha: Number, zoom:Number) {			g.lineStyle(zoom*outlinewidth, outlinecolor, outlinealpha);		g.beginFill(fillcolor, fillalpha);		g.drawCircle(zoom*center_x, zoom*center_y, zoom*radius);		g.endFill();	}	public function circle_sprite(center_x:Number, center_y:Number, radius:int, fillcolor:uint, fillalpha:Number, outlinewidth:int, outlinecolor:uint, outlinealpha: Number, zoom:Number):Sprite {	var return_sprite:Sprite = new Sprite();	var h:Graphics = return_sprite.graphics;		h.lineStyle(zoom*outlinewidth, outlinecolor, outlinealpha);	h.beginFill(fillcolor, fillalpha);	h.drawCircle(zoom*center_x, zoom*center_y, zoom*radius);	h.endFill();		return return_sprite;	}	public function getcircleradius(mechanics:int):int {		var radius:Number = 9*Math.sqrt(mechanics)/122.4		if (radius < 2) {			radius = 2;		}		return int(radius);	}	} // end of class} // end of package