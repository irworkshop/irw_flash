package{import com.google.maps.LatLng;import com.google.maps.LatLngBounds;import com.google.maps.Map;import com.google.maps.MapMoveEvent;import com.google.maps.MapEvent;import com.google.maps.MapMouseEvent;// Fuck need a better solution than this:import com.google.maps.*;import com.google.maps.interfaces.*;import com.google.maps.MapZoomEvent;import com.google.maps.MapType;import com.google.maps.controls.ZoomControl;import com.google.maps.overlays.Polygon;import com.google.maps.overlays.PolygonOptions;import com.google.maps.overlays.Polyline;import com.google.maps.overlays.PolylineOptions;import com.google.maps.overlays.EncodedPolylineData;import com.google.maps.styles.FillStyle;import com.google.maps.styles.StrokeStyle;import com.google.maps.InfoWindowOptions;import com.google.maps.services.ClientGeocoderOptions;import com.google.maps.services.ClientGeocoder;import com.google.maps.services.GeocodingEvent;import com.google.maps.overlays.Marker;import com.google.maps.overlays.MarkerOptions;import com.google.maps.InfoWindowOptions;	  import flash.geom.ColorTransform;import flash.filters.ColorMatrixFilter;import flash.geom.Point;import flash.display.MovieClip;import flash.display.Sprite//import flash.events.Event;// should figure out what's really needed from these: import flash.events.*;import flash.net.*import flash.geom.Rectangle;import flash.utils.Timer;import flash.events.Event;import flash.events.TimerEvent;import flash.events.MouseEvent;import flash.display.Sprite;import flash.ui.Mouse;import flash.display.Bitmap;	import flash.filters.BitmapFilter;import flash.filters.BitmapFilterQuality;import flash.filters.GlowFilter;import flash.filters.DropShadowFilter;import flash.filters.BlurFilter;import flash.text.TextFormat;import flash.text.TextFieldType;import flash.text.TextField;	import com.dVyper.utils.Alert;import fl.controls.Button;import org.fenton.tooltips.Rollover;//The below is customized to this use: import org.fenton.sliders.DiscreteHorizontalSlider;import org.fenton.shapes.Bounds;// county boundaries are in here in an array called colist:import org.fenton.geo_data.Countybounds;import org.fenton.geo_data.Countydata;import flash.utils.Dictionary;[SWF(width="950",height="500", frameRate="24", backgroundColor="0xFFFFFF")]public class load_county_file5_a extends MovieClip{	var map:Map;			// the county loader	private var loader:URLLoader = new URLLoader();		// What time is displayed ? 1 = 12/08, 5 = 12/10 etc.	var current_data_display_index:int = 5;		var last_county_color:int = current_data_display_index;		// Are we showing counties or tracts? Counties = 1, tracts=2;	var display_mode:int = 1;	// What's the biggest zoom level where we show counties? 	var max_county_zoom:int = 9; 		// Track whether we've already loaded the counties. This way we can start zoomed in and only load them later. 	var counties_loaded:Boolean = false;		private var initial_zoom_level:int = 4;	private var initial_center:LatLng = new LatLng(40.1,-87.1);					private var rawOptions:PolygonOptions = new PolygonOptions({ 				strokeStyle: new StrokeStyle({					color: 0x999999,					thickness: 0,					alpha: 0}), 				fillStyle: new FillStyle({					color: 0x000000,					alpha: 0.4})			})		private var hilite_options:PolygonOptions = new PolygonOptions( { strokeStyle: { color: 0x000000, alpha: 1, thickness: 2 },	  fillStyle: { alpha: 0.4 }} ); 		private var unhilite_options:PolygonOptions = new PolygonOptions( { strokeStyle: { color: 0x999999, alpha: 0,thickness: 0 },	  fillStyle: { alpha: 0.4 }} );		// Where is the mouse right now? Used to update rollover locations	private var curlatLng:LatLng;		// The rollover object	private var ro:Rollover;		// Should we display the info window? 	private var displayRollover = false;			// Array of objects that contain the actual county polygons, etc. We need to keep the original overlay object in memory in order to erase it. 	var county_objects:Array = new Array;			var red:Number = 0.3086; // luminance contrast value for red	var green:Number = 0.694; // luminance contrast value for green	var blue:Number = 0.0820; // luminance contrast value for blue	var cmf:ColorMatrixFilter = new ColorMatrixFilter([red, green, blue, 0, 0, 												   red, green, blue, 0, 0, 												   red, green, blue, 0, 0, 												   0, 0, 0, 1, 0]);			// Stuff for the time control: 		// This style of embedding requires setting the flex sdk path. Which I've done. WTF adobe?	[Embed(source='play.png')]	private var playImg:Class;	private var play1:Bitmap = new playImg ();		[Embed(source='stop.png')]	private var stopImg:Class;	private var stop1:Bitmap = new stopImg ();						private var controlsprite:Sprite = new Sprite();	private var playstate:int = 0;		var myTimer:Timer;	var yeartimer:int;	var yearTimer:DiscreteHorizontalSlider;		var glowFilter1:BitmapFilter;	// End time control stuff		private var scoreboard_format:TextFormat;	private var scoreboard_textfield:TextField;		// Need to put the actual values in this array -- Dec. 2008 is at position 1	private static var yearly_data:Array = [-1, '54', '56', '57', '58', '60'];	private static var scoreboard_textbase:String = "U.S. Broadband Subscribership: ";		// address that's entered goes in here.	private var inputfield;		// marker to represent user-entered location:	private var marker:Marker;		private var markerisshown:Boolean = false;	private static var marker_zoom:int = 12;			/// Adds for tract stuff:		// get bounds here.	var colist:Array = Countybounds.colist;	// get raw county data here: 	var codata:Array = Countydata.codata;		private var url_prefix:String = "http://irw.s3.amazonaws.com/broadband/data/national_file/county_tracts/";		// Arrays of what we've got displayed now. These tell us what to keep.	var current_display_reference:Array = new Array;	var prior_display_reference:Array = new Array;		// Array of objects that contain the actual polygons, etc. We need to keep the original overlay object in memory in order to erase it, I think. 	var display_objects:Array = new Array;		// keep a dict so it's easier to check if a shape that needs to be displayed in the current view is already displayed.	var display_dict = new Dictionary();		//// End tract stuff		// for loader: 		private var opacity_base:Number = 4.6;	var loader_textfield:TextField;	var thisTimer:Timer;			private function getcountypoly(polylines:String, levels:String, darray:Array):Polygon {		//trace("polygon from polylines: " + polylines + " levels: " + levels);		var plines:Array = polylines.split('"');		var plevels:Array = levels.split('"'); 		//Ditch the empty final elements		plines.pop();		plevels.pop();		var poly_pieces:Array = [];	// The polyline delimiting scheme I'm using is to just throw a double quote at the end of each one--so the last one is empty.		var num_points:int = plines.length;		var j:int;		for (j = 0; j < num_points; j++)		{			var shape_data:EncodedPolylineData =  new    EncodedPolylineData(plines[j],18,plevels[j],2);			poly_pieces.push(shape_data);   		}		var polygon:Polygon = Polygon.fromEncoded(poly_pieces,rawOptions);				polygon.addEventListener(MapMouseEvent.ROLL_OVER, function(e:MapMouseEvent):void {							polygon.setOptions(hilite_options);					polygon.pane.bringToTop(polygon);					displayRollover = true;					ro.setheadertext(darray[1] + ", " + darray[0]);					ro.sethtmltext("<b>Broadband:</b> (" + get_date_from_index(current_data_display_index) + ") " + get_fcc_legend_text(darray[current_data_display_index+1]) + "<br><b>Population:</b> " + darray[7]+ "<br><b>Median household income:</b> $" + darray[8] + "<br><b>Households in poverty: </b>" + darray[13] + "%" + "<br><b>Bachelors' degree (25+):</b> " + darray[9] + "%<br><b>White:</b> " + darray[10] + "%<br><b>Black:</b> " + darray[11] + "%<br><b>Hispanic:</b> " + darray[12] + "%" );					updatelatlng(e.latLng);						});						polygon.addEventListener(MapMouseEvent.ROLL_OUT, function(e:MapMouseEvent):void {					polygon.setOptions(unhilite_options);					displayRollover = false;					ro.hide();							});										return polygon;	}		private function addcountydata():void {						// how long does this load take? 				var start:Date = new Date();		trace('start:' + start.time);				//trace("load complete with data" + data_returned);		//var lines:Array = data_returned.split("\n");		//trace(lines);		for each (var thisresult:Array in codata) {								//var thisresult:Array = this_line.split("\t");						var this_data:Array = thisresult.slice(2);			//trace ("data 0 = " + this_data[0];									var poly_to_display:Polygon = getcountypoly(thisresult[0], thisresult[1], this_data);						poly_to_display.setOptions(new PolygonOptions( { fillStyle: { color: get_fcc_color(thisresult[8])}}));			// store object info here: 			var this_obj:Object = new Object;			this_obj.poly = poly_to_display;			this_obj.dataarray = this_data;			county_objects.push(this_obj);			map.addOverlay(poly_to_display);											}		trace("county object array length=" + county_objects.length);		var end:Date = new Date();		//trace('time elapsed:' + String(end.time - start.time));		//Alert.show("Time to draw overlay: " + String(end.time - start.time));				counties_loaded = true;	}			private function updatelatlng(curlatLng:LatLng):void {		if (displayRollover) {			var thispoint:Point = map.fromLatLngToViewport(curlatLng);			//trace("moving to: " + thispoint.x + ", " + thispoint.y);			ro.moveto(thispoint.x, thispoint.y);		}	}			public function addcountybystatefips():void {				if (map.getZoom() <= max_county_zoom ) {				addcountydata();		} else {			trace("starting zoomed in--deferring initial county load");		}	}			// This is a lot of work to just set the default zoom levels, but..	private function onMapPreInitialize():void {			var normalMapType:IMapType = MapType.NORMAL_MAP_TYPE;				// The important part here is the min and max zoom levels -- don't let folks zoom to far in or out. 		var myMapType:MapType=new MapType(normalMapType.getTileLayers(), normalMapType.getProjection(), "MyMap", new MapTypeOptions({tileSize: normalMapType.getTileSize(),minResolution: 4, maxResolution: 15}));		var opts:MapOptions=new MapOptions();				opts.zoom=initial_zoom_level;		opts.center=initial_center;		opts.mapTypes=[myMapType];		map.setInitOptions(opts);		}	function onMapReady():void {				setMapFilter( cmf );				//knockout the screwy controls that will get around our controls:		map.disableControlByKeyboard();		map.disableScrollWheelZoom();		// Disable double-click zoom too		// see: http://campusvirtual.uaq.mx/RevistaYaak/cdn/com/google/maps/MapAction.html 		map.setDoubleClickMode(3);							//	map.setCenter(new LatLng(41.7,-97.4), 4, MapType.NORMAL_MAP_TYPE);		map.addControl(new ZoomControl());				map.addEventListener(MapMoveEvent.MOVE_END, load_from_bounds_e);						   	}			public function load_county_file5_a() {				// initialize the rollover		ro  = new Rollover(stage);		Alert.init(stage);					map = new Map();		map.key = "ABQIAAAAD0ng6hhfw1-ZXVHi8-_1IRSYLxpl1FJwo67z08DrvK15_jpagxREG61kM4I16jOc_NzGi2_zoJPEkg";		map.sensor = "false";		map.setSize(new Point(stage.stageWidth, stage.stageHeight));				this.addChild(map);								map.addEventListener(MapEvent.MAP_PREINITIALIZE,function(e:Event):void{			onMapPreInitialize();																		});		map.addEventListener(MapEvent.MAP_READY, function(e:Event):void{			onMapReady();			addcountybystatefips();						map.addEventListener(MapZoomEvent.ZOOM_CHANGED, function(e:MapZoomEvent):void{				zoomchanged(e.zoomLevel);					 			});			draw_search_legend_box();			// Set up the time-control stuff -- the controls don't work till the data is in, so don't bother adding them until then... 			var controls:Sprite = new Sprite();			controls = drawTimeControl();			controls.x = 10;			controls.y = 10;			addChild(controls);						// map is loaded.			removeChild(loader_textfield);				thisTimer.stop();								});				map.addEventListener(MapMouseEvent.MOUSE_MOVE, function(e:MapMouseEvent):void {			curlatLng = e.latLng;		//update_curlatLng(curlatLng);		//trace("cur lat lng is: " + curlatLng);							updatelatlng(e.latLng);				});				map.addEventListener(MapMoveEvent.MOVE_END, mapmoveend);						// draw loader		var loader_format:TextFormat = new TextFormat();		loader_format.align = "left";		loader_format.font = "Arial";		loader_format.color = 0x000000;		loader_format.size = 48;		loader_format.underline = false;				var loader_Text:String = "Loading";		loader_textfield = new TextField();			loader_textfield.text = loader_Text;		loader_textfield.setTextFormat(loader_format);		loader_textfield.x = 390		loader_textfield.y = 230;			loader_textfield.width= 250;		loader_textfield.height = 100;		loader_textfield.alpha = 0.4		addChild(loader_textfield);					thisTimer = new Timer(10, 0);		thisTimer.addEventListener("timer", texttimerHandler);		thisTimer.start();									}	private function texttimerHandler(event:TimerEvent):void {		opacity_base += .1; 		var newopacity:Number = 0.66 + Math.cos(opacity_base)/3;		loader_textfield.alpha = newopacity;	}		public function mapmoveend(event:Event) : void	{		var center:LatLng = map.getCenter();		trace("center is: " + center);	}		private function get_fcc_color(fcc:int):uint {		if (fcc == 0) {			return 0xFFFFFF;		} else if (fcc == 1) {			return 0xFAf181;		} else if (fcc  == 2) {			return 0xFFF200;		} else if (fcc == 3 ) {			return 0xF9A01B;		} else if (fcc == 4 ) {			return 0xED5922;		} else if (fcc == 5) {			return 0xC44149;		} else {			return 0x00FF00;		}		}	private function setMapFilter( filter : ColorMatrixFilter ) : void	{		var s1:Sprite = map.getChildAt(1) as Sprite;		var s2:Sprite = s1.getChildAt(0) as Sprite;		s2.filters = [ filter ];   	 }	 	 // This is what gets run when the time display changes.	 private function recolor_polygons(new_data_index):void	 {		 // Need to handle display modes.		 if (display_mode == 1) {			 trace("recoloring counties: " + new_data_index);			 for each (var this_county:Object in county_objects) {			 	//trace("recoloring county: " + this_county.fips + " to: " + getdatafromindex(new_data_index, this_county));				this_county.poly.setOptions(new PolygonOptions( { fillStyle: { color: get_fcc_color(this_county.dataarray[new_data_index+1])}}) );							 }			 last_county_color = new_data_index;			 		 } else {			 trace("recoloring tracts: " + new_data_index);			for each (var this_tract:Object in display_objects) {				this_tract.poly.setOptions(new PolygonOptions( { fillStyle: { color: get_fcc_color(this_tract.darray[new_data_index+1])}}) );			}			 		 }		 		 	 }	 	 // time control stuff. 	private function drawTimeControl():Sprite {			var tcSprite:Sprite = new Sprite();				tcSprite.graphics.lineStyle(2,0x999999);		tcSprite.graphics.beginFill(0xFFFFFF,1);		tcSprite.graphics.drawRoundRect(0, 0, 930, 60, 10);		tcSprite.graphics.endFill();					var sliderLen:Number=400;			play1.height = 48;		play1.width = 48; 			stop1.height = 48;		stop1.height = 48;			controlsprite.addChild(play1);		glowFilter1= getBitmapFilter(0xF9A01B);		//controlsprite.filters = [glowFilter1];				controlsprite.x = 5;			controlsprite.y = 5;		controlsprite.addEventListener(MouseEvent.CLICK, function(e:MouseEvent):void {			controlclick()		}, false, 0, false);		controlsprite.addEventListener(MouseEvent.MOUSE_OVER, function(e:MouseEvent):void {			controlmouseover()		}, false, 0, false);		controlsprite.addEventListener(MouseEvent.MOUSE_OUT, function(e:MouseEvent):void {			controlmouseout()		}, false, 0, false);				tcSprite.addChild(controlsprite);			 		yearTimer=new DiscreteHorizontalSlider(sliderLen,4, 1, false);		tcSprite.addChild(yearTimer);		yearTimer.x=62;		yearTimer.y=2;		yearTimer.setKnobPos(5);		yearTimer.addEventListener(DiscreteHorizontalSlider.SLIDER_CHANGE, traceChange);						// set up the scoreboard, etc:				scoreboard_format = new TextFormat();		scoreboard_format.align = "left";		scoreboard_format.font = "Arial";		scoreboard_format.color = 0x000000;		scoreboard_format.size = 24;		scoreboard_format.underline = false;				var scoreboard_Text:String = scoreboard_textbase + yearly_data[current_data_display_index] + "%";		scoreboard_textfield = new TextField();			scoreboard_textfield.text = scoreboard_Text;		scoreboard_textfield.setTextFormat(scoreboard_format);		scoreboard_textfield.x = 515		scoreboard_textfield.y = 13;			scoreboard_textfield.width= 420;		scoreboard_textfield.height = 30;		tcSprite.addChild(scoreboard_textfield);				return tcSprite;	}		function reset_scoreboard(current_time_index:int):void {		if (current_time_index == 6) {			current_time_index = 5;		}		var new_scoreboard_Text:String = scoreboard_textbase + yearly_data[current_time_index] + "%";		scoreboard_textfield.text = new_scoreboard_Text;		scoreboard_textfield.setTextFormat(scoreboard_format);			}	function traceChange(e:Event): void {		var newlocation:int = yearTimer.getKnobPos();		trace("new slider position: " + String(newlocation) );		if (newlocation != current_data_display_index) {						// run update:			recolor_polygons(newlocation);						current_data_display_index = newlocation;						reset_scoreboard(yearTimer.getKnobPos());					}					}		private function controlclick():void {		trace("Controls clicked ");		if (playstate==0) {			controlsprite.removeChild(play1);			controlsprite.addChild(stop1);			playstate=1;			myTimer = new Timer(500, 5);			myTimer.addEventListener("timer", timerHandler);			myTimer.addEventListener(TimerEvent.TIMER_COMPLETE, timerCompleteHandler);			yearTimer.setKnobPos(1);			recolor_polygons(1);			yeartimer = 2;			myTimer.start();			reset_scoreboard(yearTimer.getKnobPos());			yearTimer.setDragging();		} else {			controlsprite.removeChild(stop1);			controlsprite.addChild(play1);			playstate=0;			myTimer.stop();			yearTimer.setNormal();		}	}		public function timerHandler(event:TimerEvent):void {		trace("timerHandler: " + yeartimer);		yearTimer.setKnobPos(yeartimer);		yeartimer++;		if (yeartimer-1<6) {			recolor_polygons(yeartimer-1);			reset_scoreboard(yearTimer.getKnobPos());		}	}		public function timerCompleteHandler(event:TimerEvent):void {		trace("timer is complete");		controlsprite.removeChild(stop1);		controlsprite.addChild(play1);		playstate=0;			yearTimer.setNormal();		reset_scoreboard(yearTimer.getKnobPos());	}	public function controlmouseover():void {		//Mouse.cursor="button";		controlsprite.filters = [glowFilter1];			}		public function controlmouseout():void {		//Mouse.cursor="arrow";		controlsprite.filters = [];	}				private function getBitmapFilter(color:Number):BitmapFilter {		var alpha:Number = 0.4;		var blurX:Number = 10;		var blurY:Number = 10;		var strength:Number = 4;		var inner:Boolean = false;		var knockout:Boolean = false;		var quality:Number = BitmapFilterQuality.HIGH;			return new GlowFilter(color,							  alpha,							  blurX,							  blurY,							  strength,							  quality,							  inner,							  knockout);	}			private function draw_search_legend_box():void {		var slSprite:Sprite = new Sprite();				slSprite.graphics.lineStyle(2,0x999999);		slSprite.graphics.beginFill(0xFFFFFF,1);		slSprite.graphics.drawRoundRect(1, 0, 170, 350, 10);		slSprite.graphics.endFill();		slSprite.x = 770;		slSprite.y = 100;		addChild(slSprite);				var ls:Sprite = drawLegend();		ls.x = 10;		ls.y = 100;		slSprite.addChild(ls);				var al:Sprite = drawaddresslookup();		al.x = 10;		al.y = 5;		slSprite.addChild(al);	}	private function get_fcc_legend_text(fcc:int):String {		if (fcc == 0) {			return "0%";		} else if (fcc == 1) {			return "0-20%";		} else if (fcc  == 2) {			return"20-40%";		} else if (fcc == 3 ) {			return "40-60%";		} else if (fcc == 4 ) {			return "60-80%";		} else if (fcc == 5) {			return "80-100%";		} else {			return "";		}		}		private function get_date_from_index(index:int):String {		if (index == 1) {			return "Dec. 2008";		} else if (index == 2) {			return "June 2009";		} else if (index  == 3) {			return"Dec. 2009";		} else if (index == 4 ) {			return "June 2010";		} else if (index == 5 ) {			return "Dec. 2010";		} else {			return "";		}		}			private function drawaddresslookup():Sprite {		var alSprite:Sprite = new Sprite();		var enterfield:TextField = new TextField();		enterfield.htmlText = "<font face=\"Arial,Helvetica\" size=\"14\"><b>Zoom to an address</b></font>";		enterfield.x = 0;		enterfield.y = 0;		enterfield.width = 150;		enterfield.wordWrap = true;		enterfield.multiline = true;		alSprite.addChild(enterfield);						var descriptfield:TextField = new TextField();		descriptfield.htmlText = "<font face=\"Arial,Helvetica\" size=\"12\">Enter an address to display on the map.</font>";		descriptfield.x = 0;		descriptfield.y = 18;		descriptfield.width = 150;		descriptfield.wordWrap = true;		descriptfield.multiline = true;		alSprite.addChild(descriptfield);				inputfield = new TextField();		inputfield.type = TextFieldType.INPUT;		inputfield.x = 0;		inputfield.y = 50;		inputfield.border = true;		inputfield.width = 150;		inputfield.height = 18;		inputfield.wordWrap = true;		inputfield.multiline = true;		inputfield.addEventListener(Event.CHANGE, checkTextInput, false, 0, true);				alSprite.addChild(inputfield);				var aButton:Button = new Button(); 		alSprite.addChild(aButton); 		aButton.label = "Show"; 		aButton.width = 70;		aButton.toggle =true;  		aButton.move(0, 75);		aButton.addEventListener(MouseEvent.CLICK, buttonclickHandler);				var bButton:Button = new Button(); 		alSprite.addChild(bButton); 		bButton.label = "Clear"; 		bButton.width = 70;		bButton.toggle =true;  		bButton.move(80, 75);		bButton.addEventListener(MouseEvent.CLICK, b_buttonclickHandler);								return alSprite;	}			// ridiculous function to check if there's a return entered... 	function checkTextInput(e:Event):void {		var zi:String = inputfield.text		trace("Event type: " + e.type + " " + zi);		var j:int = zi.length;		for (var i:int = 0; i<j; i++) {			if ( (zi.charCodeAt(i) == 10) || (zi.charCodeAt(i) == 13) ) {				doGeocode(inputfield.text);				inputfield.text = "";			}					}			}		function b_buttonclickHandler(event:MouseEvent):void {		if (markerisshown == true) {			map.removeOverlay(marker);			markerisshown = false;		}	}		function buttonclickHandler(event:MouseEvent):void {     	trace("Event type: " + event.type + " " + inputfield.text); 		doGeocode(inputfield.text);		inputfield.text = "";			}			private function drawLegend():Sprite {			var legendSprite:Sprite = new Sprite();			var legendfield:TextField = new TextField();		legendfield.htmlText = "<font face=\"Arial,Helvetica\" size=\"14\"><b>Legend</b></font>";		legendfield.x = 0;		legendfield.y = 10;		legendfield.width = 120;		legendfield.wordWrap = true;		legendfield.multiline = true;		legendSprite.addChild(legendfield);			var legendchatterfield:TextField = new TextField();		legendchatterfield.htmlText = "<font face=\"Arial,Helvetica\" size=\"12\">Colors show the percent of households subscribing to broadband internet.</font>";		legendchatterfield.x = 0;		legendchatterfield.y = 28;		legendchatterfield.width = 180;		legendchatterfield.wordWrap = true;		legendchatterfield.multiline = true;		legendSprite.addChild(legendchatterfield);				var legendliney:int = 80;		var legendlinex:int = 10;		var legendlineheight:int = 26;			legendSprite.graphics.lineStyle(2, 0x888888, 1);					for (var i:int = 5; i > -1; i--) {					legendSprite.graphics.beginFill(get_fcc_color(i) , 0.4);			legendSprite.graphics.drawRect(legendlinex, legendliney, 15, 15);			legendSprite.graphics.endFill();							var legendtext:TextField = new TextField();			legendtext.htmlText = "<font face=\"Arial,Helvetica\" size=\"12\">" + get_fcc_legend_text(i) + "</font>";			legendtext.x = legendlinex+30;			legendtext.y = legendliney+1;			legendtext.width = 80;			legendtext.wordWrap = true;			legendtext.multiline = true;			legendSprite.addChild(legendtext);						legendliney = legendliney + legendlineheight;		}						var sourcetext:TextField = new TextField();		sourcetext.htmlText = "<font face=\"Arial,Helvetica\" size=\"12\">Source: FCC, Census</font>";		sourcetext.x = legendlinex-5;		sourcetext.y = 230;		sourcetext.width = 140;		sourcetext.wordWrap = false;		sourcetext.multiline = false;		legendSprite.addChild(sourcetext);				return legendSprite;		}		private function doGeocode(address_lookup:String):void {        if (markerisshown == true) {			map.removeOverlay(marker);		}		// swiped from geocoder example code        var geocoder:ClientGeocoder = new ClientGeocoder();                geocoder.addEventListener(          GeocodingEvent.GEOCODING_SUCCESS,          function(event:GeocodingEvent):void {          var placemarks:Array = event.response.placemarks;          if (placemarks.length > 0) {            map.setCenter(placemarks[0].point);            marker = new Marker(placemarks[0].point);                        marker.addEventListener(MapMouseEvent.CLICK, function (event:MapMouseEvent):void {                marker.openInfoWindow(new InfoWindowOptions({content: placemarks[0].address}));            });            map.addOverlay(marker);			map.setZoom(marker_zoom);			markerisshown = true;          }        });        geocoder.addEventListener(          GeocodingEvent.GEOCODING_FAILURE,          function(event:GeocodingEvent):void {            Alert.show("Couldn't locate: '" + address_lookup + "'. Please try another address");            trace(event);            trace(event.status);			inputfield.text = "";          });        geocoder.geocode(address_lookup);      }		private function zoomchanged(newzoom:Number):void {				trace("Map zoom changed to: " + newzoom);				if ( (display_mode == 1) && (newzoom > max_county_zoom) ) {			trace("switch to tracts");			hide_counties();			load_from_bounds();						display_mode = 2;		}		if ( (display_mode == 2) && (newzoom <= max_county_zoom) ) { 			trace("switch to counties");									display_mode = 1;			if (last_county_color != current_data_display_index) {				recolor_polygons(current_data_display_index);				trace ("lagging color -- recoloring");			}			remove_all_tracts();			show_counties();														}	}	private function load_from_bounds_e(e:MapMoveEvent):void {		if (map.getZoom() > max_county_zoom ) {			load_from_bounds();		}	}	private function hide_counties():void {		var start:Date = new Date();				for each (var this_county:Object in county_objects) {				this_county.poly.hide();		 }		 		 var end:Date = new Date();		//trace('time elapsed:' + String(end.time - start.time));		//Alert.show("Time to hide counties: " + String(end.time - start.time));		 	}		private function show_counties():void {		var start:Date = new Date();		if (counties_loaded == false) {			addcountydata();		} else {			for each (var this_county:Object in county_objects) {				this_county.poly.show();		 	}		}		 var end:Date = new Date();		//trace('time elapsed:' + String(end.time - start.time));		//Alert.show("Time to show counties: " + String(end.time - start.time));		 	}			/// tract stuff: 		// Return the object we'll keep in the display list array. 	// Also need to calculate the bounds object based on the poly. 	// When we add more data, there should be a dataobject, or something included.	private function getshapeobject(thepoly:Polygon, fips:String, thedataarray:Array) {		var this_obj:Object = new Object;		this_obj.poly = thepoly;		this_obj.fips = fips;		this_obj.darray = thedataarray;		return this_obj;	}	private function remove_all_tracts():void {		var num_obj_displayed:int = display_objects.length;		var j:int;		for (j = 0; j < num_obj_displayed; j++) {			map.removeOverlay(display_objects[j].poly);			}					// Clean up the tracking vars too:			current_display_reference = new Array;		prior_display_reference = new Array;		display_objects = new Array;		display_dict = new Dictionary();				}					private function remove_from_display(fips:String):void {		// run through the display list and remove an object we don't want to display.				var num_obj_displayed:int = display_objects.length;		trace(" ^^  Attempting to remove " + fips + " from display list, which has length: " + num_obj_displayed);		var j:int;		for (j = 0; j < num_obj_displayed; j++) {			//trace(" &&& disp list " + j " : "  + display_objects[j].fips);			if (display_objects[j].fips == fips) {				//trace("located fips: " + fips + " for removal");				// remove it from display				map.removeOverlay(display_objects[j].poly);				// remove it from the display object array using splice				display_objects.splice(j, 1);				// Once we've removed an object we're done. 				j = num_obj_displayed;				display_dict[fips]=null;			}						}			}		private function gettractpoly(polylines:String, levels:String, darray:Array):Polygon {		//trace("polygon from polylines: " + polylines + " levels: " + levels);		var plines:Array = polylines.split('"');		var plevels:Array = levels.split('"'); 		//Ditch the empty final elements		plines.pop();		plevels.pop();		var poly_pieces:Array = [];	// The polyline delimiting scheme I'm using is to just throw a double quote at the end of each one--so the last one is empty.		var num_points:int = plines.length;		var j:int;		for (j = 0; j < num_points; j++)		{			var shape_data:EncodedPolylineData =  new    EncodedPolylineData(plines[j],18,plevels[j],2);			poly_pieces.push(shape_data);   		}		var polygon:Polygon = Polygon.fromEncoded(poly_pieces,rawOptions);				polygon.addEventListener(MapMouseEvent.ROLL_OVER, function(e:MapMouseEvent):void {							polygon.setOptions(hilite_options);					polygon.pane.bringToTop(polygon);					displayRollover = true;					ro.setheadertext(darray[15] + " " + darray[1]);					ro.sethtmltext("<b>Broadband:</b> (" + get_date_from_index(current_data_display_index) + ") " + get_fcc_legend_text(darray[current_data_display_index+1]) + "<br><b>Population:</b> " + darray[7]+ "<br><b>Median household income:</b> $" + darray[8] + "<br><b>Households in poverty: </b>" + darray[13] + "%" + "<br><b>Bachelors' degree (25+):</b> " + darray[9] + "%<br><b>White:</b> " + darray[10] + "%<br><b>Black:</b> " + darray[11] + "%<br><b>Hispanic:</b> " + darray[12] + "%" );					updatelatlng(e.latLng);						});						polygon.addEventListener(MapMouseEvent.ROLL_OUT, function(e:MapMouseEvent):void {					polygon.setOptions(unhilite_options);					displayRollover = false;					ro.hide();							});										return polygon;	}			private function addtractdata(data_returned:String):void {		//trace("load complete with data" + data_returned);		var lineresults:Array = data_returned.split("\n");		var firstresult:Array = lineresults[0].split("\t");				// Check the county fips of the first result. If it's already loaded, don't load it. If it's not, marked that it is loaded now. Minimize chances of race condition. 		if (display_dict[firstresult[16]]) {			trace(firstresult[16] + " already displayed.. not adding again");		} else {									// Now record that it's actually displayed			display_dict[firstresult[16]] = 1;					for each (var data_returned:String in lineresults) {				if (data_returned.length > 0) {										var thisresult:Array = data_returned.split("\t");					var this_data:Array = thisresult.slice(2);										var poly_to_display:Polygon = gettractpoly(thisresult[0], thisresult[1], this_data)					trace("received data for " + thisresult[16]);										poly_to_display.setOptions(new PolygonOptions( { fillStyle: { color: get_fcc_color(this_data[current_data_display_index+1])}}));										// this_tract.poly.setOptions(new PolygonOptions( { fillStyle: { color: get_fcc_color(this_tract.darray[new_data_index+1])}}) );										map.addOverlay(poly_to_display);															// Get the whole shape object so we can add it to the displayed objects array. 					var this_obj:Object = getshapeobject(poly_to_display, thisresult[1], this_data);					display_objects.push(this_obj);				}			}		}	}			public function addcountybyfips(fips:String):void {		trace("adding county " + fips );		var loader:URLLoader = new URLLoader();		//configureListeners(loader);						loader.addEventListener ( IOErrorEvent.IO_ERROR, handleIOError );        loader.addEventListener ( HTTPStatusEvent.HTTP_STATUS, handleHttpStatus );        loader.addEventListener ( SecurityErrorEvent.SECURITY_ERROR, handleSecurityError );         		loader.addEventListener(Event.COMPLETE, function(e:Event):void{			addtractdata(loader.data.toString());		});				var request1:URLRequest = new URLRequest(url_prefix + fips + ".txt");			try {            loader.load(request1);      	} catch (error:Error) {        	trace(" ****Unable to load requested documents.");		}	}			   function handleIOError ( event:IOErrorEvent ):void	{		trace ( "Load failed: IO error: " + event.text );	}	function handleHttpStatus ( event:HTTPStatusEvent ):void	{		trace ( "Load result: HTTP Status = " + event.status );	}	function handleSecurityError ( event:SecurityErrorEvent ):void	{		trace ( "Load failed: Security Error: " + event.text );	}			function load_from_bounds():void {		var bounds:LatLngBounds = map.getLatLngBounds();		var southWest:LatLng = bounds.getSouthWest();		var northEast:LatLng = bounds.getNorthEast();					var maxY:Number = northEast.lat();		var minY:Number = southWest.lat();		var leftX:Number = southWest.lng();		var rightX:Number = northEast.lng();						// make the bounds slightly wider		var newmaxY:Number = (  ( (maxY + minY) / 2 ) + ( (maxY - minY) * 3/4) );		var newminY:Number = (  ( (maxY + minY) / 2 ) - ( (maxY - minY) * 3/4) );		var newleftX:Number = ( ( (leftX + rightX) / 2 ) - ( (rightX - leftX ) * 3/4) );		var newrightX:Number = ( ( (leftX + rightX) / 2 ) + ( (rightX - leftX ) * 3/4) );						//trace("old bounds: "  + maxY + " " + minY + " " + leftX + " " + rightX);		//trace("newer bounds: " + " " + newmaxY + " " + newminY + " " + newleftX + " " + newrightX);							// Step 1: Check for counties that need to be removed.		prior_display_reference = current_display_reference;		current_display_reference = [];		var displayed:int = prior_display_reference.length;				for (var j:int = displayed-1; j> -1; j--) {			if (!(prior_display_reference[j][1].check_viewport_overlap(newminY, newmaxY, newleftX, newrightX))) {				trace("*** Must remove county: " + prior_display_reference[j][0]);				remove_from_display(prior_display_reference[j][0]);			}		}						// check the viewport against the bounds: 		//var counties_to_show = [];		var cocount:int = colist.length;				// testing this loop time in development		var start:Date = new Date();				for (var k:Number = cocount-1; k > -1; k--) {			if (colist[k][1].check_viewport_overlap(newminY, newmaxY, newleftX, newrightX)) {				current_display_reference.push(colist[k]);			}		}		//trace("****\n");		for each(var county:Array in current_display_reference) {			//trace("Must display: " + county[0]);						if (display_dict[county[1]]) {				trace ("already displayed: " + county[0]);							} else {				//trace("new display! " + county[0]);				// add the county				addcountybyfips(county[0]);				// We're not adding the county to the display dictionary yet-- because we gotta load a file asynchronously we don't wanna mark the shape as added until it's really displayed. 							}		}				var end:Date = new Date();		trace('time elapsed:' + (end.time - start.time)); 			// This runs in about 4 milliseconds through the 3200-ish counties. 				}	function printboundse(event:Event):void {		trace("current zoom level is " + map.getZoom());		load_from_bounds();	}		}}