package{/// A demo that includes all county bounding boxes internally and figures out which should be displayed for the maps given viewport. Seems to run efficiently: ~ 4ms per move on this machine. import com.google.maps.LatLng;import com.google.maps.LatLngBounds;import com.google.maps.Map;import com.google.maps.MapMoveEvent;import com.google.maps.MapEvent;import com.google.maps.MapMouseEvent;import com.google.maps.MapMoveEvent;import com.google.maps.MapZoomEvent;import com.google.maps.MapType;import com.google.maps.controls.ZoomControl;import com.google.maps.overlays.Polygon;import com.google.maps.overlays.PolygonOptions;import com.google.maps.overlays.Polyline;import com.google.maps.overlays.PolylineOptions;import com.google.maps.overlays.EncodedPolylineData;import com.google.maps.styles.FillStyle;import com.google.maps.styles.StrokeStyle;import flash.geom.Point;import flash.utils.Dictionary;import flash.display.MovieClip;import flash.display.Sprite// Need to whittle the below down...import flash.events.*;import flash.net.*import flash.geom.Rectangle;import org.fenton.shapes.Bounds;import org.fenton.tooltips.Rollover;// county boundaries are in here in an array called colist:import org.fenton.geo_data.Countybounds;[SWF(width="700",height="500", frameRate="24", backgroundColor="0xFFFFFF")]public class boundstest4 extends MovieClip{	// get bounds here.	var colist:Array = Countybounds.colist;	var map:Map;		private var url_prefix:String = "http://irw.s3.amazonaws.com/broadband/data/county_files/";		// Where is the mouse right now? Used to update rollover locations	private var curlatLng:LatLng;		// Arrays of what we've got displayed now. These tell us what to keep.	var current_display_reference:Array = new Array;	var prior_display_reference:Array = new Array;		// Array of objects that contain the actual polygons, etc. We need to keep the original overlay object in memory in order to erase it, I think. 	var display_objects:Array = new Array;		// keep a dict so it's easier to check if a shape that needs to be displayed in the current view is already displayed.	var display_dict = new Dictionary();		// The rollover object	private var ro:Rollover;		// Should we display the info window? 	private var displayRollover = false;				// Basic display options	private var rawOptions:PolygonOptions = new PolygonOptions({ 				strokeStyle: new StrokeStyle({					color: 0x999999,					thickness: 0,					alpha: 0.0}), 				fillStyle: new FillStyle({					color: 0x000000,					alpha: 0.5})			})					private var hilite_options:PolygonOptions = new PolygonOptions( { strokeStyle: { color: 0x000000, alpha: 1, thickness: 2 },	  fillStyle: { alpha: 0.5 }} ); 		private var unhilite_options:PolygonOptions = new PolygonOptions( { strokeStyle: { color: 0x999999, alpha: 0.0,thickness: 0 },	  fillStyle: { alpha: 0.5 }} );			// Return the object we'll keep in the display list array. 	// Also need to calculate the bounds object based on the poly. 	// When we add more data, there should be a dataobject, or something included.	private function getshapeobject(thepoly:Polygon, fips:String) {		var this_obj:Object = new Object;		this_obj.poly = thepoly;		this_obj.fips = fips;		return this_obj;	}		private function remove_from_display(fips:String):void {		// run through the display list and remove an object we don't want to display.				var num_obj_displayed:int = display_objects.length;		trace(" ^^  Attempting to remove " + fips + " from display list, which has length: " + num_obj_displayed);		var j:int;		for (j = 0; j < num_obj_displayed; j++) {			//trace(" &&& disp list " + j " : "  + display_objects[j].fips);			if (display_objects[j].fips == fips) {				//trace("located fips: " + fips + " for removal");				// remove it from display				map.removeOverlay(display_objects[j].poly);				// remove it from the display object array using splice				display_objects.splice(j, 1);				// Once we've removed an object we're done. 				j = num_obj_displayed;				display_dict[fips]=null;			}						}	}		private function updatelatlng(curlatLng:LatLng):void {		if (displayRollover) {			var thispoint:Point = map.fromLatLngToViewport(curlatLng);			//trace("moving to: " + thispoint.x + ", " + thispoint.y);			ro.moveto(thispoint.x, thispoint.y);		}	}		private function getpoly(polylines:String, levels:String):Polygon {		var plines:Array = polylines.split('"');		var plevels:Array = levels.split('"'); 		//Ditch the empty final elements		plines.pop();		plevels.pop();		var poly_pieces:Array = [];	// The polyline delimiting scheme I'm using is to just throw a double quote at the end of each one--so the last one is empty.		var num_points:int = plines.length;		var j:int;		for (j = 0; j < num_points; j++)		{			var shape_data:EncodedPolylineData =  new    EncodedPolylineData(plines[j],18,plevels[j],2);			poly_pieces.push(shape_data);   		}		var polygon:Polygon = Polygon.fromEncoded(poly_pieces,rawOptions);				return polygon;	}		private function adddata(data_returned:String):void {		//trace("load complete with data" + data_returned);		var thisresult:Array = data_returned.split("\t");				// double check that is hasn't already been added already here. Because file loading is asynchronous we can't really be sure unless we double check. 		if (display_dict[thisresult[1]]) {			trace(thisresult[1] + " already displayed.. not adding again");		} else {			var poly_to_display:Polygon = getpoly(thisresult[2], thisresult[3])			trace("received data for " + thisresult[1]);							poly_to_display.addEventListener(MapMouseEvent.ROLL_OVER, function(e:MapMouseEvent):void {					poly_to_display.setOptions(hilite_options);				//polymessage = msg;				//polygon.pane.bringToTop(polygon);				// We gotta call the menu move here too, otherwise we can end up with the infowindow never visible.				displayRollover = true;				ro.sethtmltext(thisresult[0]);				updatelatlng(e.latLng);				});				poly_to_display.addEventListener(MapMouseEvent.ROLL_OUT, function(e:MapMouseEvent):void {				poly_to_display.setOptions(unhilite_options);				displayRollover = false;				ro.hide();					});							map.addOverlay(poly_to_display);			// Now record that it's actually displayed			display_dict[thisresult[1]] = 1;						// Get the whole shape object so we can add it to the displayed objects array. 			var this_obj:Object = getshapeobject(poly_to_display, thisresult[1]);			display_objects.push(this_obj);						//trace("Added " + thisresult[0] + " to display list");		}	}			public function addcountybyfips(fips:String):void {		trace("adding county " + fips );		var loader:URLLoader = new URLLoader();		//configureListeners(loader);				loader.addEventListener(Event.COMPLETE, function(e:Event):void{			adddata(loader.data.toString());		});				var request1:URLRequest = new URLRequest(url_prefix + fips + ".txt");			try {            loader.load(request1);      	} catch (error:Error) {        	trace(" ****Unable to load requested documents.");		}	}					function printbounds():void {		var bounds:LatLngBounds = map.getLatLngBounds();		var southWest:LatLng = bounds.getSouthWest();		var northEast:LatLng = bounds.getNorthEast();					var maxY:Number = northEast.lat();		var minY:Number = southWest.lat();		var leftX:Number = southWest.lng();		var rightX:Number = northEast.lng();						// Step 1: Check for counties that need to be removed.		prior_display_reference = current_display_reference;		current_display_reference = [];		var displayed:int = prior_display_reference.length;				for (var j:int = displayed-1; j> -1; j--) {			if (!(prior_display_reference[j][1].check_viewport_overlap(minY, maxY, leftX, rightX))) {				trace("*** Must remove county: " + prior_display_reference[j][0]);				remove_from_display(prior_display_reference[j][0]);			}		}						// check the viewport against the bounds: 		//var counties_to_show = [];		var cocount:int = colist.length;				// testing this loop time in development		var start:Date = new Date();				for (var k:Number = cocount-1; k > -1; k--) {			if (colist[k][1].check_viewport_overlap(minY, maxY, leftX, rightX)) {				current_display_reference.push(colist[k]);			}		}		//trace("****\n");		for each(var county:Array in current_display_reference) {			//trace("Must display: " + county[0]);						if (display_dict[county[1]]) {				trace ("already displayed: " + county[0]);							} else {				//trace("new display! " + county[0]);				// add the county				addcountybyfips(county[0]);				// We're not adding the county to the display dictionary yet-- because we gotta load a file asynchronously we don't wanna mark the shape as added until it's really displayed. 							}		}				var end:Date = new Date();		trace('time elapsed:' + (end.time - start.time)); 			// This runs in about 4 milliseconds through the 3200-ish counties. 				}	function printboundse(event:Event):void {		trace("current zoom level is " + map.getZoom());		printbounds();	}		public function boundstest4() {				// initialize the rollover		ro  = new Rollover(stage);				map = new Map();				map.key = "ABQIAAAAD0ng6hhfw1-ZXVHi8-_1IRTm2E_fMzPNNPQWz2AeEXeYkSD5QhQjzVgo-IesHaawQxgV1otoWX8v-g";		map.sensor = "false";		map.setSize(new Point(stage.stageWidth, stage.stageHeight));				this.addChild(map);		map.addEventListener(MapEvent.MAP_READY, onMapReady);						function onMapReady(event:Event):void {			map.setCenter(new LatLng(32.435,-86.573), 10, MapType.NORMAL_MAP_TYPE);			map.addControl(new ZoomControl());			printbounds();						map.addEventListener(MapMoveEvent.MOVE_END, printboundse);						map.addEventListener(MapMouseEvent.MOUSE_MOVE, function(e:MapMouseEvent):void {				curlatLng = e.latLng;				//update_curlatLng(curlatLng);				//trace("cur lat lng is: " + curlatLng);		        								updatelatlng(e.latLng);			});    		}	}}}