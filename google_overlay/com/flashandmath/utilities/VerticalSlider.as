/* ***********************************************************************ActionScript 3 Tutorial by Barbara Kaskoszwww.flashandmath.comLast modified: April 2, 2008************************************************************************ *//*The class is alomost identical to the HorizontalSlider class except forthe way some elements (like tick marks) are drawn. Please see HorizontalSlider classfor comments. Since both classes inherit the rotation property of the Sprite class,you can make a vertical slider horizonatal and vice-versa by rotating by 90 degrees.*/package com.flashandmath.utilities {	    import flash.display.Sprite;		import flash.display.Shape;      import flash.events.*;		import flash.geom.Rectangle;     public class VerticalSlider extends Sprite {	  	public static const SLIDER_CHANGE:String = "sliderChange";		protected var nLength:Number;	protected var nInnerLength:Number;	protected var shTrack:Shape;	protected var spKnob:Sprite;	protected var nKnobColor:Number;	protected var nKnobOpacity:Number;	protected var nKnobWidth:Number;	protected var nKnobHeight:Number;	protected var nNumTics:int;	protected var sStyle:String;	protected var rBounds:Rectangle;	protected var _isPressed:Boolean;	protected var TicColor:uint;	protected var KnobOffset_x:int;			protected var prevY:Number;		public function VerticalSlider(len:Number, numtics:int){					this.nNumTics = numtics;		this.TicColor = 0x666666;			this.nKnobWidth=20;		this.nKnobHeight = 10;		 		this.KnobOffset_x = 5;					this.nLength=len;		this.nInnerLength = len - nKnobHeight;				this._isPressed=false;				this.nKnobColor=0x666666;		this.nKnobOpacity=1.0;		rBounds=new Rectangle(KnobOffset_x,0,0,nLength-nKnobHeight);		shTrack=new Shape();		this.addChild(shTrack);		spKnob=new Sprite();		spKnob.x = KnobOffset_x;		spKnob.y = 0;		this.addChild(spKnob);		drawSlider();		activateSlider();		setKnobPos(0);					}			protected function drawSlider():void {				shTrack.graphics.clear();		spKnob.graphics.clear();					shTrack.graphics.lineStyle(2,TicColor);		// top tic:		shTrack.graphics.moveTo(0,nKnobHeight/2);		shTrack.graphics.lineTo(2*KnobOffset_x+nKnobWidth,nKnobHeight/2);		// bottom tic:		shTrack.graphics.moveTo(0, nLength-nKnobHeight/2);		shTrack.graphics.lineTo(2*KnobOffset_x+nKnobWidth,nLength-nKnobHeight/2);					// draw smaller intermediate tics		for (var i:int = 1; i< nNumTics; i++) {			shTrack.graphics.moveTo(KnobOffset_x, nKnobHeight/2 + i*nInnerLength/nNumTics);			shTrack.graphics.lineTo(KnobOffset_x+nKnobWidth,nKnobHeight/2 + i*nInnerLength/nNumTics);		}		//nNumTics		//innerLength						spKnob.graphics.beginFill(nKnobColor,nKnobOpacity);		spKnob.graphics.drawRect(0, 0, nKnobWidth, nKnobHeight);		spKnob.graphics.endFill();		spKnob.x = KnobOffset_x;											}		protected function activateSlider(): void {				spKnob.addEventListener(MouseEvent.MOUSE_DOWN,downKnob);				spKnob.addEventListener(MouseEvent.MOUSE_UP,upKnob);			}		protected function downKnob(e:MouseEvent): void {				spKnob.startDrag(false,rBounds);				stage.addEventListener(MouseEvent.MOUSE_UP,upOutsideKnob);				stage.addEventListener(MouseEvent.MOUSE_MOVE,handleMove);				prevY=spKnob.y;				_isPressed=true;							}		protected function handleMove(e:MouseEvent):void {			  var curY=spKnob.y;		if(_isPressed){			if(Math.abs(curY-prevY)>0){				prevY=curY;				dispatchEvent(new Event(VerticalSlider.SLIDER_CHANGE));				e.updateAfterEvent();				}			}			}		protected function upOutsideKnob(e:MouseEvent): void {				spKnob.stopDrag();				stage.removeEventListener(MouseEvent.MOUSE_UP,upOutsideKnob);				stage.removeEventListener(MouseEvent.MOUSE_MOVE,handleMove);				_isPressed=false;			}		protected function upKnob(e:MouseEvent): void {				spKnob.stopDrag();				stage.removeEventListener(MouseEvent.MOUSE_UP,upOutsideKnob);				stage.removeEventListener(MouseEvent.MOUSE_MOVE,handleMove);				_isPressed=false;					}			public function get isPressed():Boolean {					return _isPressed;			}		public function setKnobPos(a:Number):void {				spKnob.y=a;			}				public function getKnobPos():Number {				return spKnob.y;					}		public function changeKnobSize(s:Number):void {				nKnobWidth=s;				drawSlider();			}		public function changeKnobColor(colo:Number):void {				nKnobColor=colo;				drawSlider();			}		public function changeKnobOpacity(opac:Number):void {				nKnobOpacity=opac;				drawSlider();			}			public function getSliderLen():Number{				return nLength;			}		public function destroy():void {				spKnob.removeEventListener(MouseEvent.MOUSE_DOWN,downKnob);				spKnob.removeEventListener(MouseEvent.MOUSE_UP,upKnob);				stage.removeEventListener(MouseEvent.MOUSE_UP,upOutsideKnob);				stage.removeEventListener(MouseEvent.MOUSE_MOVE,handleMove);				spKnob.graphics.clear();				shTrack.graphics.clear();				this.removeChild(spKnob);				this.removeChild(shTrack);				shTrack=null;				spKnob=null;					}			}}