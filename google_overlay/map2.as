package{import com.google.maps.LatLng;import com.google.maps.LatLngBounds;import com.google.maps.Map;import com.google.maps.MapMoveEvent;import com.google.maps.MapEvent;import com.google.maps.MapMouseEvent;import com.google.maps.MapType;import flash.geom.Point;import flash.display.MovieClip;import flash.display.Spriteimport flash.events.Event;import fl.core.UIComponent;import flash.display.Bitmap;import flash.display.BitmapData;import flash.geom.Rectangle;import org.fenton.tooltips.Rollover;import com.dVyper.utils.Alert;[SWF(width="700",height="500", frameRate="24", backgroundColor="0xFFFFFF")]public class map2 extends MovieClip{//private var ref:UIComponent;private var ref:Sprite;// put latlngs here:private var points:Array = new Array();// and corresponding pixels in here:private var points_pixels:Array = new Array();private var ro:Rollover;private var mapwidth:int=700;private var mapheight:int=500;private var numpoints:int = 20000;private var radius:int = 2;private var line_width:int = 1;private var crit_radius:int = Math.pow((radius+line_width),2);// Secondary circlepublic var t:Sprite = new Sprite();// When the map is dragged, don't redraw unless we really have to--just keep track of how far it's been moved. private var last_center:LatLng;private var first_center:LatLng;var map:Map = new Map();	public function mapmovestart(event:Event) : void	{		last_center=map.getCenter();		first_center=last_center;		//trace("start: " + String(last_center));	}		public function mapmoveend(event:Event) : void	{		var p:Point = map.fromLatLngToViewport(last_center);		var xoffset:Number = p.x-mapwidth/2;		var yoffset:Number = p.y-mapheight/2;		//trace("end: " + String(p) + " " + String(xoffset) + " " + String(yoffset));		ref.x += xoffset;		ref.y += yoffset;						recalculate_latlng_pixels();	}		public function mapmovestep(event:Event) : void	{		var new_center:LatLng = map.getCenter();		var p:Point = map.fromLatLngToViewport(last_center);		var xoffset:Number = p.x-mapwidth/2;		var yoffset:Number = p.y-mapheight/2;		//trace("end: " + String(p) + " " + String(xoffset) + " " + String(yoffset));		ref.x += xoffset;		ref.y += yoffset;		last_center=new_center;			}		public function recalculate_latlng_pixels(): void 	{		// Dump what's in the pixels array and repopulate it		points_pixels = new Array();		for (var k:Number = numpoints-1; k > -1; k--) {			var a:Point = map.fromLatLngToViewport(points[k]);			points_pixels.push(a);		}	}	public function translate_latlng_pixels(offset:Point): void	{		// When the map is just moved, it's (probably) faster to just move the points rather than reproject them. 		for (var k:Number = numpoints-1; k > -1; k--) {			points_pixels[k].x += offset.x;			points_pixels[k].y += offset.y;		}	}	public function drawStuff() : void	{		//ref = new UIComponent(); // creating a UI component Object		ref = new Sprite();		this.addChild(ref); // add UI component to stage		var width:Number = mapwidth;		var height:Number = mapheight;		var startpoint:Number;						 		// Create a biggish bitmapdata				var b:BitmapData = new BitmapData(width, height, true, 0x00FFFFFF);				// Create a marker to clone:		var s:Sprite = new Sprite();		s.graphics.lineStyle(line_width, 0x666666, 1);		s.graphics.beginFill(0xFF0000, 0.25);		s.graphics.drawCircle(radius+line_width, radius+line_width, radius);						var circle:BitmapData = new BitmapData(2*radius+2*line_width, 2*radius+2*line_width, true, 0x00000000);		circle.draw(s);				// Create an alphabitmap layer -- documentation on this is crap		// It seems like the color in this bitmap is ignored and only the alpha level is included. 				var t:Sprite = new Sprite();		t.graphics.beginFill(0x000000, 1);		t.graphics.drawCircle(radius+line_width, radius+line_width, radius);		var circleAlpha:BitmapData = new BitmapData(2*radius+2*line_width, 2*radius+line_width, true, 0x00000000);		circleAlpha.draw(t);								// get a rectangle		var copyrect:Rectangle = new Rectangle(0,0,2*radius+2*line_width,2*radius+2*line_width);				var zeropoint:Point = new Point(0,0);				recalculate_latlng_pixels();				// copy points 				for (var k:Number = numpoints-1; k >-1; k--) {			var a:Point = points_pixels[k];			var c:Point= new Point(a.x-radius-line_width, a.y-radius-line_width);			b.copyPixels(circle, copyrect, c , circleAlpha, zeropoint, true);   			}				// draw the bitmapdata to a bitmap and add it. 				var bi:Bitmap = new Bitmap(b);		bi.x=0;		bi.y=0;				// Ignore mouse events. If we listen to them, they don't propagate to the map underneath.		ref.mouseEnabled = false;		ref.addChild( bi);					}			public function moveacircle(x:int, y:int):void {		t.x = x;		t.y = y;	}		private function initcircle() : void {			t.graphics.lineStyle(line_width, 0x000000, 1);		t.graphics.drawCircle(0, 0, radius);		ref.addChild(t);		t.x=-1000;		t.y=-1000;	}		private function hittest(point:Point):void {		var cx:Number = point.x;		var cy:Number = point.y;		var d2:int;		var min_d2:int=1000;		var close_point:Point;		var close_point_index:int;				for (var i:int = points_pixels.length-1; i > -1; i--) {		// What's exponent in flex? 			d2=Math.pow((cx-points_pixels[i].x),2)+Math.pow((cy-points_pixels[i].y),2);			//Alert.show("cx: " + cx + " cy: " + cy + " pointsx " + points[i].x + " pointsy: " + points[i].y + " d2: " + d2);									if (d2 < min_d2) {				min_d2 = d2;				close_point = points_pixels[i];				close_point_index = i;			}		}		if (min_d2 <= crit_radius) {			//trace("mousing over: " + String(close_point_index));			ro.sethtmltext("<font face='Arial Bold'>Random point number: " + String(close_point_index) + "</font>");			ro.moveto(close_point.x,close_point.y);			// we gotta make up for the fact that the underlying sprite may have moved			moveacircle(close_point.x-ref.x, close_point.y-ref.y);			} else {			ro.hide();			moveacircle(-1000, -1000);		}				}		public function map2() {		// initialize the rollover		ro  = new Rollover(stage);				//var map:Map = new Map();		map.key = "ABQIAAAAD0ng6hhfw1-ZXVHi8-_1IRTm2E_fMzPNNPQWz2AeEXeYkSD5QhQjzVgo-IesHaawQxgV1otoWX8v-g";		map.sensor = "false";		map.setSize(new Point(stage.stageWidth, stage.stageHeight));				this.addChild(map);		map.addEventListener(MapEvent.MAP_READY, onMapReady);						function onMapReady(event:Event):void {			map.setCenter(new LatLng(40.736072,-73.992062), 14, MapType.NORMAL_MAP_TYPE);						// create fake data						var bounds:LatLngBounds = map.getLatLngBounds();    		var southWest:LatLng = bounds.getSouthWest();    		var northEast:LatLng = bounds.getNorthEast();    		var lngSpan:Number = northEast.lng() - southWest.lng();    		var latSpan:Number = northEast.lat() - southWest.lat();       			for (var i:Number = 0; i < numpoints; i++) {           		//trace( String(southWest.lat()) + " " + String(latSpan)  + " " +  String(southWest.lng()) + " " + String(lngSpan));				var latlng:LatLng = new LatLng(southWest.lat() + latSpan * Math.random(), southWest.lng()+lngSpan * Math.random());				points.push(latlng);			       		}						// end fake data..			// initialize dVyper's alert class:        	Alert.init(stage);							var start:Date = new Date();			trace('start:' + start.time);			drawStuff();									var end:Date = new Date();			trace('time elapsed:' + (end.time - start.time)); 				Alert.show("Drew  " + String(numpoints) + " points. Draw time= " +  String(end.time - start.time) + " milliseconds", {buttons:["OK"]});			initcircle();								map.addEventListener(MapMoveEvent.MOVE_START, mapmovestart);			map.addEventListener(MapMoveEvent.MOVE_END, mapmoveend);			map.addEventListener(MapMoveEvent.MOVE_STEP, mapmovestep);			map.addEventListener(MapMouseEvent.MOUSE_MOVE, function(e:MapMouseEvent):void {				hittest(map.fromLatLngToViewport(e.latLng));			});		}				// create some fake data									}	} // end of class} // end of package