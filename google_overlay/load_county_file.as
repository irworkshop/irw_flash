package{import com.google.maps.LatLng;import com.google.maps.LatLngBounds;import com.google.maps.Map;import com.google.maps.MapMoveEvent;import com.google.maps.MapEvent;import com.google.maps.MapMouseEvent;import com.google.maps.MapMoveEvent;import com.google.maps.MapZoomEvent;import com.google.maps.MapType;import com.google.maps.controls.ZoomControl;import com.google.maps.overlays.Polygon;import com.google.maps.overlays.PolygonOptions;import com.google.maps.overlays.Polyline;import com.google.maps.overlays.PolylineOptions;import com.google.maps.overlays.EncodedPolylineData;import com.google.maps.styles.FillStyle;import com.google.maps.styles.StrokeStyle;import com.google.maps.InfoWindowOptions;import flash.geom.Point;import flash.display.MovieClip;import flash.display.Sprite//import flash.events.Event;// should figure out what's really needed from these: import flash.events.*;import flash.net.*import flash.geom.Rectangle;[SWF(width="700",height="500", frameRate="24", backgroundColor="0xFFFFFF")]public class load_county_file extends MovieClip{	var map:Map;		private var url_prefix:String = "http://irw.s3.amazonaws.com/broadband/data/county_files/";		private var rawOptions:PolygonOptions = new PolygonOptions({ 				strokeStyle: new StrokeStyle({					color: 0x999999,					thickness: 2,					alpha: 0.5}), 				fillStyle: new FillStyle({					color: 0x000000,					alpha: 0.5})			})			private function getpoly(polylines:String, levels:String):Polygon {		var plines:Array = polylines.split('"');		var plevels:Array = levels.split('"'); 		//Ditch the empty final elements		plines.pop();		plevels.pop();		var poly_pieces:Array = [];	// The polyline delimiting scheme I'm using is to just throw a double quote at the end of each one--so the last one is empty.		var num_points:int = plines.length;		var j:int;		for (j = 0; j < num_points; j++)		{			var shape_data:EncodedPolylineData =  new    EncodedPolylineData(plines[j],18,plevels[j],2);			poly_pieces.push(shape_data);   		}		var polygon:Polygon = Polygon.fromEncoded(poly_pieces,rawOptions);		return polygon;	}		private function adddata(data_returned:String):void {		trace("load complete with data" + data_returned);		var thisresult:Array = data_returned.split("\t");		map.addOverlay(getpoly(thisresult[2], thisresult[3]));			}			public function addcountybyfips(fips:String):void {		var loader:URLLoader = new URLLoader();		//configureListeners(loader);				loader.addEventListener(Event.COMPLETE, function(e:Event):void{			adddata(loader.data.toString());		});				var request1:URLRequest = new URLRequest(url_prefix + fips + ".txt");			try {            loader.load(request1);      	} catch (error:Error) {        	trace("Unable to load requested documents.");		}	}				function onMapReady():void {		map.setCenter(new LatLng(32.435,-86.573), 9, MapType.NORMAL_MAP_TYPE);		map.addControl(new ZoomControl());						addcountybyfips("01001");		addcountybyfips("01003");		addcountybyfips("01005");		addcountybyfips("01007");		addcountybyfips("01009");		addcountybyfips("01011");		   	}			public function load_county_file() {				map = new Map();				map.key = "ABQIAAAAD0ng6hhfw1-ZXVHi8-_1IRTm2E_fMzPNNPQWz2AeEXeYkSD5QhQjzVgo-IesHaawQxgV1otoWX8v-g";		map.sensor = "false";		map.setSize(new Point(stage.stageWidth, stage.stageHeight));				this.addChild(map);		map.addEventListener(MapEvent.MAP_READY, function(e:Event):void{			onMapReady();		});	}}}