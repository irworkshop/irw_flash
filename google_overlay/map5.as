package{// can we import flex libraries? import mx.charts.PieChart;import mx.charts.series.PieSeries;import mx.collections.ArrayCollection;import com.google.maps.LatLng;import com.google.maps.LatLngBounds;import com.google.maps.Map;import com.google.maps.MapMoveEvent;import com.google.maps.MapEvent;import com.google.maps.MapMouseEvent;import com.google.maps.MapType;import com.google.maps.controls.ZoomControl;import com.google.maps.controls.MapTypeControl;// styling importsimport com.google.maps.StyledMapType;import com.google.maps.StyledMapTypeOptions;import com.google.maps.styles.MapTypeStyleElementType;import com.google.maps.styles.MapTypeStyleFeatureType;import com.google.maps.styles.MapTypeStyleRule;import com.google.maps.styles.MapTypeStyle;import flash.geom.Point;import flash.display.MovieClip;import flash.display.Spriteimport flash.events.Event;import fl.core.UIComponent;import flash.display.Bitmap;import flash.display.BitmapData;import flash.geom.ColorTransform;import flash.filters.ColorMatrixFilter;import flash.geom.Rectangle;import org.fenton.tooltips.Rollover;import com.dVyper.utils.Alert;import flash.text.TextField;import flash.text.TextFieldAutoSize;import flash.text.TextFormat;import flash.text.TextFieldType; import fl.controls.Label;import fl.controls.Slider;import fl.events.SliderEvent;import fl.controls.SliderDirection;import flash.ui.Mouse; import flash.events.*;[SWF(width="700",height="500", frameRate="24", backgroundColor="0xFFFFFF")]public class map5 extends MovieClip{//private var ref:UIComponent;private var ref:Sprite;private var overlayholder:Sprite = new Sprite();// put latlngs here:private var points:Array = new Array();// and corresponding pixels in here:private var points_pixels:Array = new Array();private var ro:Rollover;private var mapwidth:int=700;private var mapheight:int=500;private var zoomlevel:int = 4;private var numpoints:int = 500;//private var radius:int = 6;// These are the interior radii of the circle bitmaps;private var min_radius:int = 4;private var max_radius:int = 15;private var circles_array:Array = new Array;private var circles_alpha_array:Array = new Array;private var rollover_circles_array:Array = new Array;private var line_width:int = 2;//private var crit_radius:int = 4+Math.pow((radius+line_width+2),2);// When the map is dragged, don't redraw unless we really have to--just keep track of how far it's been moved. private var last_center:LatLng;private var first_center:LatLng;var map:Map = new Map();	public function mapmovestart(event:Event) : void	{		last_center=map.getCenter();		first_center=last_center;		//trace("start: " + String(last_center));	}		public function mapmoveend(event:Event) : void	{		var p:Point = map.fromLatLngToViewport(last_center);		var xoffset:Number = p.x-mapwidth/2;		var yoffset:Number = p.y-mapheight/2;		//trace("end: " + String(p) + " " + String(xoffset) + " " + String(yoffset));		ref.x += xoffset;		ref.y += yoffset;				overlayholder.removeChild(ref);		recalculate_latlng_pixels();		drawStuff();		init_rollover_circle();	}		public function mapmovestep(event:Event) : void	{		var new_center:LatLng = map.getCenter();		var p:Point = map.fromLatLngToViewport(last_center);		var xoffset:Number = p.x-mapwidth/2;		var yoffset:Number = p.y-mapheight/2;		//trace("end: " + String(p) + " " + String(xoffset) + " " + String(yoffset));		ref.x += xoffset;		ref.y += yoffset;		last_center=new_center;			}		public function recalculate_latlng_pixels(): void 	{		// Dump what's in the pixels array and repopulate it		points_pixels = new Array();		for (var k:Number = numpoints-1; k > -1; k--) {			var a:Point = map.fromLatLngToViewport(points[k].latlng);			var point_holder:Object = new Object;			point_holder.point = a;			point_holder.radius = points[k].pointsize;			points_pixels.push(point_holder);		}	}	public function translate_latlng_pixels(offset:Point): void	{		// When the map is just moved, it's (probably) faster to just move the points rather than reproject them. 		for (var k:Number = numpoints-1; k > -1; k--) {			points_pixels[k].point.x += offset.x;			points_pixels[k].point.y += offset.y;		}	}		public function initialize_circles(): void 	{				for (var k:Number = min_radius; k < max_radius; k++) {						// Create a marker to clone:			var s:Sprite = new Sprite();			s.graphics.lineStyle(line_width, 0x666666, 1);			s.graphics.beginFill(0xFF0000, 0.4);			s.graphics.drawCircle(k+line_width, k+line_width, k);									var circle:BitmapData = new BitmapData(2*k+2*line_width, 2*k+2*line_width, true, 0x00000000);			circle.draw(s);			circles_array[k]=circle;									// Create an alphabitmap layer -- documentation on this is crap			// It seems like the color in this bitmap is ignored and only the alpha level is included. 						var t:Sprite = new Sprite();			t.graphics.beginFill(0x000000, 1);			t.graphics.drawCircle(k+line_width, k+line_width, k);			var circleAlpha:BitmapData = new BitmapData(2*k+2*line_width, 2*k+line_width, true, 0x00000000);			circleAlpha.draw(t);			circles_alpha_array[k]=circleAlpha;		}	}		public function drawStuff() : void	{		//ref = new UIComponent(); // creating a UI component Object		ref = new Sprite();		overlayholder.addChild(ref); // add UI component to stage		var width:Number = mapwidth;		var height:Number = mapheight;		var startpoint:Number;						 		// Create a biggish bitmapdata				var b:BitmapData = new BitmapData(width, height, true, 0x00FFFFFF);						var zeropoint:Point = new Point(0,0);				recalculate_latlng_pixels();				// copy points 				for (var k:Number = numpoints-1; k >-1; k--) {			var a:Point = points_pixels[k].point;			var size:int = points_pixels[k].radius;			var copyrect:Rectangle = new Rectangle(0,0,2*size+2*line_width,2*size+2*line_width);			var c:Point= new Point(a.x-size-line_width, a.y-size-line_width);			//trace("Trying to draw " + String(size));			b.copyPixels(circles_array[size], copyrect, c , circles_alpha_array[size], zeropoint, true);   			}						// draw the bitmapdata to a bitmap and add it. 				var bi:Bitmap = new Bitmap(b);		bi.x=0;		bi.y=0;				// Ignore mouse events. If we listen to them, they don't propagate to the map underneath.		ref.mouseEnabled = false;		ref.addChild( bi);					}			public function moveacircle(circleindex:int, x:int, y:int):void {		for (var k:Number = min_radius; k < max_radius; k++) {			if (k==circleindex) {				rollover_circles_array[circleindex].sprite.x = x;				rollover_circles_array[circleindex].sprite.y = y;				rollover_circles_array[circleindex].shown = true;			}			else {				if (rollover_circles_array[k].shown) {					rollover_circles_array[k].shown = false;					rollover_circles_array[k].sprite.x = -1000;					rollover_circles_array[k].sprite.y = -1000;														}			}		}	}	public function hidecircles():void {		for (var k:Number = min_radius; k < max_radius; k++) {			if (rollover_circles_array[k].shown) {					rollover_circles_array[k].shown = false;					rollover_circles_array[k].sprite.x = -1000;					rollover_circles_array[k].sprite.y = -1000;														}		}	}	private function init_rollover_circle() : void {			for (var k:Number = min_radius; k < max_radius; k++) {// rollover_circles_array			var t:Sprite = new Sprite();				t.graphics.lineStyle(line_width, 0x000000, 1);			t.graphics.drawCircle(0, 0, k);			var rollover_holder:Object = new Object;			rollover_holder.sprite = t;			var f:Boolean = false;			rollover_holder.shown = f;			rollover_circles_array[k] = rollover_holder;			ref.addChild(t);			t.x=-1000;			t.y=-1000;		}	}		private function hittest(point:Point):void {		var cx:Number = point.x;		var cy:Number = point.y;		var d2:int;		var min_d2:int=1000;		var close_point:Point;		var close_point_index:int;		var show_rollover:Boolean = false;				for (var i:int = points_pixels.length-1; i > -1; i--) {		// What's exponent in flex? 			d2=Math.pow((cx-points_pixels[i].point.x),2)+Math.pow((cy-points_pixels[i].point.y),2);			//Alert.show("cx: " + cx + " cy: " + cy + " pointsx " + points[i].x + " pointsy: " + points[i].y + " d2: " + d2);									if (d2 < min_d2) {				if (d2 < 50 + Math.pow(points_pixels[i].radius,2)) {					min_d2 = d2;					close_point = points_pixels[i].point;					close_point_index = i;					show_rollover = true;				}			}		}				if (show_rollover) {			//trace("mousing over: " + String(close_point_index));			ro.sethtmltext("<font face='Arial Bold'>Random point number: " + String(close_point_index) + " with size: " + String(points_pixels[close_point_index].radius ) + "</font>");						// Doing it this way would make the markers appear in a fixed position			//ro.moveto(close_point.x,close_point.y);						ro.moveto(point.x, point.y);									//trace("Near: " + String(close_point.x) + " " + String(close_point.y));			// we gotta make up for the fact that the underlying sprite may have moved			moveacircle(points_pixels[close_point_index].radius, close_point.x-ref.x, close_point.y-ref.y);			} else {			ro.hide();			hidecircles();		}				}			private function exitHandler(e:Event) {	// make sure the rollover isn't shown when the mouse is off the stage. Without this, the rollovers were appearing if a bubble was at the 0,0 position on the map.	// Not clear how many browsers this works on... 		ro.hide();		hidecircles();	}		public function map5() {		// initialize the rollover		ro  = new Rollover(stage);		// draw the bitmaps		initialize_circles();				//var map:Map = new Map();		map.key = "ABQIAAAAD0ng6hhfw1-ZXVHi8-_1IRTm2E_fMzPNNPQWz2AeEXeYkSD5QhQjzVgo-IesHaawQxgV1otoWX8v-g";		map.sensor = "false";		map.setSize(new Point(stage.stageWidth, stage.stageHeight));				this.addChild(map);		this.addChild(overlayholder);		overlayholder.mouseEnabled = false;		map.addEventListener(MapEvent.MAP_READY, onMapReady);						function onMapReady(event:Event):void {						//			//											  var simplerStyles:Array = [			 // new MapTypeStyle(MapTypeStyleFeatureType.ROAD_LOCAL,			//	  MapTypeStyleElementType.GEOMETRY,			//	  [MapTypeStyleRule.hue(0x00ff00),			//	  MapTypeStyleRule.saturation(100)]),			 // new MapTypeStyle(MapTypeStyleFeatureType.LANDSCAPE,			//	  MapTypeStyleElementType.GEOMETRY,			//	  [MapTypeStyleRule.lightness(-100)])			new MapTypeStyle(MapTypeStyleFeatureType.POI,				MapTypeStyleElementType.ALL,			 				[MapTypeStyleRule.visibility("off")]),			new MapTypeStyle(MapTypeStyleFeatureType.ADMINISTRATIVE_PROVINCE,				MapTypeStyleElementType.GEOMETRY,			 				[MapTypeStyleRule.lightness(-100)])											  ];				  var simplerOptions:StyledMapTypeOptions = new StyledMapTypeOptions({			  name: 'Simpler',			  alt: 'Simpler'		  });				  var styledMapType:StyledMapType = new StyledMapType(simplerStyles, simplerOptions);				  map.addMapType(styledMapType);		  //map.addControl(new MapTypeControl());									//			//						map.setCenter(new LatLng(39.8, -98.5), zoomlevel, styledMapType);			//NORMAL_MAP_TYPE  PHYSICAL_MAP_TYPE			// create fake data						var bounds:LatLngBounds = map.getLatLngBounds();    		var southWest:LatLng = bounds.getSouthWest();    		var northEast:LatLng = bounds.getNorthEast();    		var lngSpan:Number = northEast.lng() - southWest.lng();    		var latSpan:Number = northEast.lat() - southWest.lat();       			for (var i:Number = 0; i < numpoints; i++) {           		//trace( String(southWest.lat()) + " " + String(latSpan)  + " " +  String(southWest.lng()) + " " + String(lngSpan));				var latlng:LatLng = new LatLng(southWest.lat() + latSpan * Math.random(), southWest.lng()+lngSpan * Math.random());				var pointsize = int(min_radius+(max_radius-min_radius)*Math.random());				var pointdata:Object = new Object;				pointdata.latlng = latlng;				pointdata.pointsize = pointsize;				points.push(pointdata);			       		}						// end fake data..			// initialize dVyper's alert class:        	Alert.init(stage);							var start:Date = new Date();			trace('start:' + start.time);			var red:Number = 0.3086; // luminance contrast value for red			var green:Number = 0.694; // luminance contrast value for green			var blue:Number = 0.0820; // luminance contrast value for blue			var cmf:ColorMatrixFilter = new ColorMatrixFilter([red, green, blue, 0, 0, 		                                                   red, green, blue, 0, 0, 		                                                   red, green, blue, 0, 0, 	                                                  	   0, 0, 0, 1, 0]);															//setMapFilter( cmf );			drawStuff();						drawzoombox();			//map.addControl(new ZoomControl());						var end:Date = new Date();			trace('time elapsed:' + (end.time - start.time)); 				Alert.show("Drew  " + String(numpoints) + " random points with radii between " + String(min_radius) + " and " + String(max_radius) + " pixels. Draw time= " +  String(end.time - start.time) + " milliseconds", {buttons:["OK"]});			init_rollover_circle();								map.addEventListener(MapMoveEvent.MOVE_START, mapmovestart);			map.addEventListener(MapMoveEvent.MOVE_END, mapmoveend);			map.addEventListener(MapMoveEvent.MOVE_STEP, mapmovestep);			map.addEventListener(MapMouseEvent.MOUSE_MOVE, function(e:MapMouseEvent):void {				hittest(map.fromLatLngToViewport(e.latLng));			});			stage.addEventListener(Event.MOUSE_LEAVE, exitHandler);		}				}private function drawzoombox():void {	var slidersprite = new Sprite();					 	slidersprite.graphics.lineStyle(1,0x999999);	slidersprite.graphics.beginFill(0xFFFFFF, 1);      	slidersprite.graphics.drawRect(0,0,50,90);	slidersprite.graphics.endFill();		// Make the cursor an arrow when it's over the zoom control	//slidersprite.addEventListener(MouseEvent.MOUSE_OVER, function(e:MouseEvent):void {	//				Mouse.cursor="arrow";	//		}, false, 0, false);	//slidersprite.addEventListener(MouseEvent.MOUSE_OUT, function(e:MouseEvent):void {	//				Mouse.cursor="hand";	//		}, false, 0, false);			 	 	// We have to explicitly set the width of all the text label fields.	// If we don't, their default size is big enough that it interferes	// with the mouse event listeners on the map.	var zoomtitle:TextField = new TextField();	//myLabel.autoSize = TextFieldAutoSize.LEFT;	zoomtitle.text = "ZOOM";	zoomtitle.x=5;	zoomtitle.y=5;	zoomtitle.width=40;	slidersprite.addChild(zoomtitle);	 	var zoomplus:TextField = new TextField();	//myLabel.autoSize = TextFieldAutoSize.LEFT;	zoomplus.text = "+";	zoomplus.x=33;	zoomplus.y=18;	zoomplus.width = 10;	slidersprite.addChild(zoomplus);	 	 	var zoomminus:TextField = new TextField();	//myLabel.autoSize = TextFieldAutoSize.LEFT;	zoomminus.text = "-";	zoomminus.x=33;	zoomminus.y=68;	zoomminus.width = 10;	slidersprite.addChild(zoomminus);      	 	 	var zoomslider:Slider = new Slider();	//mySlider.addEventListener(SliderEvent.THUMB_DRAG, thumbDragHandler);	 	zoomslider.snapInterval = 1;	zoomslider.tickInterval = 1;	zoomslider.maximum = 8;	zoomslider.minimum = 4;	zoomslider.value = zoomlevel;	zoomslider.x = 20;	zoomslider.y = 27;	zoomslider.liveDragging = true;	 	 	//s.move(myLabel.x, myLabel.y + myLabel.height);	 	zoomslider.direction = SliderDirection.VERTICAL;	zoomslider.setSize(20, 50);	 	slidersprite.addChild(zoomslider);	// Ignore mouse clicks	slidersprite.addEventListener(MouseEvent.MOUSE_DOWN,onStopPropDown,false, 0, true);	//slidersprite.addEventListener(MouseEvent.MOUSE_UP,onStopPropDown,false, 0, true);	 	 	slidersprite.x = 10;	slidersprite.y = 10;	this.addChild(slidersprite);	zoomslider.addEventListener(SliderEvent.CHANGE, zoomChange);		slidersprite.addEventListener(MouseEvent.MOUSE_OVER, function(e:MouseEvent):void {	//				Mouse.cursor="arrow";		ro.hide();		hidecircles();	});}function zoomChange(e:SliderEvent):void {    var newzoom:int = e.target.value;    trace("new zoom is " + newzoom);	if (newzoom != zoomlevel) {		map.setZoom(newzoom);		zoomlevel=newzoom;	}     }function onStopPropDown(evt:MouseEvent):void {//output.text = "stopProp down";    evt.stopPropagation();}private function setMapFilter( filter : ColorMatrixFilter ) : void{	var s1:Sprite = map.getChildAt(1) as Sprite;	var s2:Sprite = s1.getChildAt(0) as Sprite;	s2.filters = [ filter ];    }	} // end of class} // end of package